/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.18_02 from the
 * contents of Wurst.xs. Do not edit this file, edit Wurst.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "Wurst.xs"
#/*$Id: Wurst.xs,v 1.10 2008/03/14 15:43:31 mmundry Exp $ */

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "align_i.h"
#include "altscores.h"
#include "bad_angle.h"
#include "class_model.h"
#include "classifyStructure.h"
#include "cmp_dmat_i.h"
#include "compound.h"
#include "coord.h"
#include "coord_i.h"
#include "coordinfo_i.h"
#include "geo_gap.h"
#include "lsqf.h"
#include "model.h"
#include "multialign.h"
#include "pair_set_chim.h"
#include "pair_set_i.h"
#include "pair_set_p_i.h"
#include "param_fx_i.h"
#include "pdbin_i.h"
#include "pdbout_i.h"
#include "prob_vec_i.h"
#include "read_ac.h"
#include "read_ac_i.h"
#include "read_ac_strct.h"
#include "read_ac_strct_i.h"
#include "read_blst.h"
#include "read_mat.h"
#include "read_sec_i.h"
#include "read_seq_i.h"
#include "rescore.h"
#include "score_fx_i.h"
#include "score_mat_i.h"
#include "score_probvec.h"
#include "score_sec_i.h"
#include "score_smat.h"
#include "scratch.h"
#include "sec_s_i.h"
#include "silly.h"
#include "scor_set.h"
#include "scor_set_i.h"
#include "seq.h"


static double
constant(char *name, int len, int arg)
{
    errno = 0;
    if (strEQ(name + 0, "WURST_H")) {    /*  removed */
#       ifdef WURST_H
        return WURST_H;
#       else
        errno = ENOENT;
        return 0;
#       endif
    }
    errno = EINVAL;
    return 0;
}

typedef struct aa_clssfcn       Aa_clssfcn;
typedef struct aa_strct_clssfcn Aa_strct_clssfcn ;
typedef struct prob_vec         Prob_vec;
typedef struct sec_s_data       Sec_s_data;
typedef struct seq              Seq;
typedef struct seq_array        Seq_array;
typedef struct sub_mat          Sub_mat;
typedef struct score_mat        Score_mat;
typedef struct pair_set         Pair_set;
typedef struct coord            Coord;
typedef void                    Param;
typedef struct FXParam          FXParam;
typedef float                   RSParam;
typedef struct seqprof          Seqprof;
typedef struct scor_set         Scor_set;
typedef struct clssfcn          Clssfcn;

#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#line 96 "Wurst.c"

XS(XS_Wurst_constant); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_constant)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::constant", "sv, arg");
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 88 "Wurst.xs"
    STRLEN        len;
#line 112 "Wurst.c"
	SV *	sv = ST(0);
	char *	s = SvPV(sv, len);
	int	arg = (int)SvIV(ST(1));
	double	RETVAL;
	dXSTARG;
#line 94 "Wurst.xs"
    RETVAL = constant(s,len,arg);
#line 120 "Wurst.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_sec_s_data_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_sec_s_data_read)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::sec_s_data_read", "fname");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	char *	fname = (char *)SvPV_nolen(ST(0));
	Sec_s_data *	RETVAL;

	RETVAL = sec_s_data_read(fname);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Sec_s_dataPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_sec_s_data_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_sec_s_data_string)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::sec_s_data_string", "sec_s_data");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Sec_s_data *	sec_s_data;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Sec_s_dataPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sec_s_data = INT2PTR(Sec_s_data *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::sec_s_data_string",
			"sec_s_data", "Sec_s_dataPtr");

	RETVAL = sec_s_data_string(sec_s_data);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Sec_s_dataPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sec_s_dataPtr_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Sec_s_dataPtr::DESTROY", "sec_s_data");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Sec_s_data *	sec_s_data;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sec_s_data = INT2PTR(Sec_s_data *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"Sec_s_dataPtr::DESTROY",
			"sec_s_data");
#line 115 "Wurst.xs"
        sec_s_data_destroy (sec_s_data);
#line 206 "Wurst.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Wurst_seq_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_seq_read)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::seq_read", "fname");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	char *	fname = (char *)SvPV_nolen(ST(0));
	Seq *	RETVAL;

	RETVAL = seq_read(fname);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "SeqPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_seq_from_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_seq_from_string)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::seq_from_string", "s");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	char *	s = (char *)SvPV_nolen(ST(0));
	Seq *	RETVAL;

	RETVAL = seq_from_string(s);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "SeqPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_seq_get_1); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_seq_get_1)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::seq_get_1", "ps_a, n");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Seq_array **	ps_a;
	size_t	n = (size_t)SvUV(ST(1));
	Seq *	RETVAL;

	if (sv_derived_from(ST(0), "Seq_arrayPtrPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ps_a = INT2PTR(Seq_array **,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::seq_get_1",
			"ps_a", "Seq_arrayPtrPtr");

	RETVAL = seq_get_1(ps_a, n);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "SeqPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_seq_num); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_seq_num)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::seq_num", "ps_a");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Seq_array **	ps_a;
	size_t	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Seq_arrayPtrPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ps_a = INT2PTR(Seq_array **,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::seq_num",
			"ps_a", "Seq_arrayPtrPtr");

	RETVAL = seq_num(ps_a);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_seq_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_seq_size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::seq_size", "seq");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Seq *	seq;
	size_t	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    seq = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::seq_size",
			"seq", "SeqPtr");

	RETVAL = seq_size(seq);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_seq_print); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_seq_print)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::seq_print", "seq");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Seq *	seq;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    seq = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::seq_print",
			"seq", "SeqPtr");

	RETVAL = seq_print(seq);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Wurst_seq_read_many); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_seq_read_many)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::seq_read_many", "fname, s_a = NULL");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	const char *	fname = (const char *)SvPV_nolen(ST(0));
	Seq_array **	s_a;
	Seq_array **	RETVAL;

	if (items < 2)
	    s_a = NULL;
	else {
	    if (sv_derived_from(ST(1), "Seq_arrayPtrPtr")) {
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		s_a = INT2PTR(Seq_array **,tmp);
	    }
	    else
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			    "Wurst::seq_read_many",
			    "s_a", "Seq_arrayPtrPtr");
	}

	RETVAL = seq_read_many(fname, s_a);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Seq_arrayPtrPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_seq_print_many); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_seq_print_many)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::seq_print_many", "ps_a");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Seq_array **	ps_a;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Seq_arrayPtrPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ps_a = INT2PTR(Seq_array **,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::seq_print_many",
			"ps_a", "Seq_arrayPtrPtr");

	RETVAL = seq_print_many(ps_a);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_SeqPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_SeqPtr_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "SeqPtr::DESTROY", "seq");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Seq *	seq;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    seq = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"SeqPtr::DESTROY",
			"seq");
#line 161 "Wurst.xs"
        seq_destroy (seq);
#line 480 "Wurst.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Seq_arrayPtrPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Seq_arrayPtrPtr_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Seq_arrayPtrPtr::DESTROY", "s_a");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Seq_array **	s_a;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s_a = INT2PTR(Seq_array **,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"Seq_arrayPtrPtr::DESTROY",
			"s_a");
#line 169 "Wurst.xs"
        seq_array_destroy (s_a);
#line 510 "Wurst.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Wurst_sub_mat_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_sub_mat_read)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::sub_mat_read", "fname");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	const char *	fname = (const char *)SvPV_nolen(ST(0));
	Sub_mat *	RETVAL;

	RETVAL = sub_mat_read(fname);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Sub_matPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_sub_mat_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_sub_mat_string)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::sub_mat_string", "s_m");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Sub_mat *	s_m;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Sub_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s_m = INT2PTR(Sub_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::sub_mat_string",
			"s_m", "Sub_matPtr");

	RETVAL = sub_mat_string(s_m);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Wurst_sub_mat_shift); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_sub_mat_shift)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::sub_mat_shift", "s_m, x");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Sub_mat *	s_m;
	float	x = (float)SvNV(ST(1));
	Sub_mat *	RETVAL;

	if (sv_derived_from(ST(0), "Sub_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s_m = INT2PTR(Sub_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::sub_mat_shift",
			"s_m", "Sub_matPtr");

	RETVAL = sub_mat_shift(s_m, x);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Sub_matPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_sub_mat_scale); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_sub_mat_scale)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::sub_mat_scale", "s_m, bot, top");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Sub_mat *	s_m;
	int	bot = (int)SvIV(ST(1));
	int	top = (int)SvIV(ST(2));

	if (sv_derived_from(ST(0), "Sub_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s_m = INT2PTR(Sub_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::sub_mat_scale",
			"s_m", "Sub_matPtr");

	sub_mat_scale(s_m, bot, top);
    }
    XSRETURN_EMPTY;
}


XS(XS_Wurst_sub_mat_get_by_i); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_sub_mat_get_by_i)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::sub_mat_get_by_i", "s_m, ndx1, ndx2");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Sub_mat *	s_m;
	int	ndx1 = (int)SvIV(ST(1));
	int	ndx2 = (int)SvIV(ST(2));
	float	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Sub_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s_m = INT2PTR(Sub_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::sub_mat_get_by_i",
			"s_m", "Sub_matPtr");

	RETVAL = sub_mat_get_by_i(s_m, ndx1, ndx2);
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_sub_mat_get_by_c); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_sub_mat_get_by_c)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::sub_mat_get_by_c", "s_m, ndx1, ndx2");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Sub_mat *	s_m;
	char	ndx1 = (char)*SvPV_nolen(ST(1));
	char	ndx2 = (char)*SvPV_nolen(ST(2));
	float	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Sub_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s_m = INT2PTR(Sub_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::sub_mat_get_by_c",
			"s_m", "Sub_matPtr");

	RETVAL = sub_mat_get_by_c(s_m, ndx1, ndx2);
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_sub_mat_set_by_i); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_sub_mat_set_by_i)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::sub_mat_set_by_i", "s_m, ndx1, ndx2, f");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Sub_mat *	s_m;
	int	ndx1 = (int)SvIV(ST(1));
	int	ndx2 = (int)SvIV(ST(2));
	float	f = (float)SvNV(ST(3));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Sub_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s_m = INT2PTR(Sub_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::sub_mat_set_by_i",
			"s_m", "Sub_matPtr");
#line 215 "Wurst.xs"
        RETVAL = sub_mat_set_by_i (s_m, ndx1, ndx2, f);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 736 "Wurst.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_sub_mat_set_by_c); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_sub_mat_set_by_c)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::sub_mat_set_by_c", "s_m, ndx1, ndx2, f");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Sub_mat *	s_m;
	char	ndx1 = (char)*SvPV_nolen(ST(1));
	char	ndx2 = (char)*SvPV_nolen(ST(2));
	float	f = (float)SvNV(ST(3));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Sub_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s_m = INT2PTR(Sub_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::sub_mat_set_by_c",
			"s_m", "Sub_matPtr");
#line 230 "Wurst.xs"
        RETVAL = sub_mat_set_by_c (s_m, ndx1, ndx2, f);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 776 "Wurst.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Sub_matPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sub_matPtr_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Sub_matPtr::DESTROY", "s_m");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Sub_mat *	s_m;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s_m = INT2PTR(Sub_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"Sub_matPtr::DESTROY",
			"s_m");
#line 244 "Wurst.xs"
        sub_mat_destroy (s_m);
#line 807 "Wurst.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Wurst_coord_2_bin); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_2_bin)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::coord_2_bin", "c, fname");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Coord *	c;
	const char *	fname = (const char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::coord_2_bin",
			"c", "CoordPtr");
#line 257 "Wurst.xs"
        RETVAL = coord_2_bin (c, fname);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 844 "Wurst.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_coord_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::coord_name", "c");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Coord *	c;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::coord_name",
			"c", "CoordPtr");

	RETVAL = coord_name(c);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Wurst_coord_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::coord_size", "c");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Coord *	c;
	size_t	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::coord_size",
			"c", "CoordPtr");

	RETVAL = coord_size(c);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_coord_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_read)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::coord_read", "fname");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	const char *	fname = (const char *)SvPV_nolen(ST(0));
	Coord *	RETVAL;

	RETVAL = coord_read(fname);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "CoordPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_coord_get_seq); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_get_seq)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::coord_get_seq", "c");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Coord *	c;
	Seq *	RETVAL;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::coord_get_seq",
			"c", "CoordPtr");

	RETVAL = coord_get_seq(c);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "SeqPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_coord_has_sec_s); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_has_sec_s)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::coord_has_sec_s", "c");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Coord *	c;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::coord_has_sec_s",
			"c", "CoordPtr");

	RETVAL = coord_has_sec_s(c);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_coord_get_sec_s); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_get_sec_s)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::coord_get_sec_s", "c");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Coord *	c;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::coord_get_sec_s",
			"c", "CoordPtr");

	RETVAL = coord_get_sec_s(c);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Wurst_coord_2_pdb); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_2_pdb)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::coord_2_pdb", "fname, c, seq = NULL");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	const char *	fname = (const char *)SvPV_nolen(ST(0));
	Coord *	c;
	Seq *	seq;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(1), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::coord_2_pdb",
			"c", "CoordPtr");

	if (items < 3)
	    seq = NULL;
	else {
	    if (sv_derived_from(ST(2), "SeqPtr")) {
		IV tmp = SvIV((SV*)SvRV(ST(2)));
		seq = INT2PTR(Seq *,tmp);
	    }
	    else
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			    "Wurst::coord_2_pdb",
			    "seq", "SeqPtr");
	}
#line 295 "Wurst.xs"
        RETVAL = coord_2_pdb (fname, c, seq);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 1079 "Wurst.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_coord_2_spdb); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_2_spdb)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3 || items > 4)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::coord_2_spdb", "fname, c, scorset, seq = NULL");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	const char *	fname = (const char *)SvPV_nolen(ST(0));
	Coord *	c;
	Scor_set *	scorset;
	Seq *	seq;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(1), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::coord_2_spdb",
			"c", "CoordPtr");

	if (sv_derived_from(ST(2), "Scor_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    scorset = INT2PTR(Scor_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::coord_2_spdb",
			"scorset", "Scor_setPtr");

	if (items < 4)
	    seq = NULL;
	else {
	    if (sv_derived_from(ST(3), "SeqPtr")) {
		IV tmp = SvIV((SV*)SvRV(ST(3)));
		seq = INT2PTR(Seq *,tmp);
	    }
	    else
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			    "Wurst::coord_2_spdb",
			    "seq", "SeqPtr");
	}
#line 310 "Wurst.xs"
        RETVAL = coord_2_spdb (fname, c, seq, scorset);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 1141 "Wurst.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_coord_c_n_dist); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_c_n_dist)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::coord_c_n_dist", "c, i, j, sqrt_flag");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Coord *	c;
	unsigned int	i = (unsigned int)SvUV(ST(1));
	unsigned int	j = (unsigned int)SvUV(ST(2));
	unsigned int	sqrt_flag = (unsigned int)SvUV(ST(3));
	float	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::coord_c_n_dist",
			"c", "CoordPtr");

	RETVAL = coord_c_n_dist(c, i, j, sqrt_flag);
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_coord_calc_psi); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_calc_psi)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::coord_calc_psi", "c");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Coord *	c;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::coord_calc_psi",
			"c", "CoordPtr");

	coord_calc_psi(c);
    }
    XSRETURN_EMPTY;
}


XS(XS_Wurst_coord_calc_phi); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_calc_phi)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::coord_calc_phi", "c");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Coord *	c;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::coord_calc_phi",
			"c", "CoordPtr");

	coord_calc_phi(c);
    }
    XSRETURN_EMPTY;
}


XS(XS_Wurst_coord_psi); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_psi)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::coord_psi", "c, j, shift_min");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Coord *	c;
	const size_t	j = (const size_t)SvUV(ST(1));
	const float	shift_min = (float)SvNV(ST(2));
	float	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::coord_psi",
			"c", "CoordPtr");
#line 342 "Wurst.xs"
       RETVAL = coord_psi (c, j, shift_min);
       if (RETVAL == BAD_ANGLE)
           XSRETURN_UNDEF;
#line 1271 "Wurst.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_coord_phi); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_phi)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::coord_phi", "c, j, shift_min");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Coord *	c;
	const size_t	j = (const size_t)SvUV(ST(1));
	const float	shift_min = (float)SvNV(ST(2));
	float	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::coord_phi",
			"c", "CoordPtr");
#line 355 "Wurst.xs"
       RETVAL = coord_phi (c, j, shift_min);
       if (RETVAL == BAD_ANGLE)
           XSRETURN_UNDEF;
#line 1308 "Wurst.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_coord_geo_gap); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_geo_gap)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::coord_geo_gap", "c, scale, max");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Coord *	c;
	float	quad;
	float	linear;
	float	logistic;
	unsigned int	num_gap;
	float	scale = (float)SvNV(ST(1));
	float	max = (float)SvNV(ST(2));

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::coord_geo_gap",
			"c", "CoordPtr");
#line 369 "Wurst.xs"
        {
            int i;
            i = coord_geo_gap (c, &quad, &linear, &logistic, \
                               &num_gap, scale, max);
            if (i == EXIT_FAILURE)
                XSRETURN_EMPTY;
        }
#line 1351 "Wurst.c"
	XSprePUSH;	EXTEND(SP,4);
	PUSHs(sv_newmortal());
	sv_setnv(ST(0), (double)quad);
	PUSHs(sv_newmortal());
	sv_setnv(ST(1), (double)linear);
	PUSHs(sv_newmortal());
	sv_setnv(ST(2), (double)logistic);
	PUSHs(sv_newmortal());
	sv_setuv(ST(3), (UV)num_gap);
    }
    XSRETURN(4);
}


XS(XS_Wurst_dme_thresh); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_dme_thresh)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::dme_thresh", "frac, c1, c2, thresh");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	float	frac;
	Coord *	c1;
	Coord *	c2;
	float	thresh = (float)SvNV(ST(3));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(1), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    c1 = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::dme_thresh",
			"c1", "CoordPtr");

	if (sv_derived_from(ST(2), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    c2 = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::dme_thresh",
			"c2", "CoordPtr");
#line 384 "Wurst.xs"
        RETVAL = dme_thresh (&frac, c1, c2, thresh);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 1408 "Wurst.c"
	sv_setnv(ST(0), (double)frac);
	SvSETMAGIC(ST(0));
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_pdb_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_pdb_read)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::pdb_read", "fname, acq_c, chain");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	const char *	fname = (const char *)SvPV_nolen(ST(0));
	const char *	acq_c = (const char *)SvPV_nolen(ST(1));
	const char	chain = (char)*SvPV_nolen(ST(2));
	Coord *	RETVAL;

	RETVAL = pdb_read(fname, acq_c, chain);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "CoordPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_CoordPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_CoordPtr_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "CoordPtr::DESTROY", "c");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Coord *	c;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"CoordPtr::DESTROY",
			"c");
#line 406 "Wurst.xs"
        coord_destroy (c);
#line 1466 "Wurst.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Wurst_make_model); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_make_model)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::make_model", "p, seq, coord");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Pair_set *	p;
	Seq *	seq;
	Coord *	coord;
	Coord *	RETVAL;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    p = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::make_model",
			"p", "Pair_setPtr");

	if (sv_derived_from(ST(1), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    seq = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::make_model",
			"seq", "SeqPtr");

	if (sv_derived_from(ST(2), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    coord = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::make_model",
			"coord", "CoordPtr");

	RETVAL = make_model(p, seq, coord);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "CoordPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_model_pdb_num); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_model_pdb_num)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::model_pdb_num", "mdl, resnum");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Coord *	mdl;
	int	resnum = (int)SvIV(ST(1));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mdl = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::model_pdb_num",
			"mdl", "CoordPtr");
#line 423 "Wurst.xs"
        RETVAL = model_pdb_num(mdl, resnum);
        if (RETVAL == -99999)
            XSRETURN_UNDEF;
#line 1553 "Wurst.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_model_res_num); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_model_res_num)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::model_res_num", "mdl, mnum");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Coord *	mdl;
	int	mnum = (int)SvIV(ST(1));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mdl = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::model_res_num",
			"mdl", "CoordPtr");
#line 434 "Wurst.xs"
        RETVAL = model_res_num(mdl, mnum);
        if (RETVAL == -1)
          XSRETURN_UNDEF;
#line 1589 "Wurst.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_coord_2_pnlty); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_2_pnlty)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::coord_2_pnlty", "c, f");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Coord *	c;
	float	f = (float)SvNV(ST(1));
	float *	RETVAL;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::coord_2_pnlty",
			"c", "CoordPtr");

	RETVAL = coord_2_pnlty(c, f);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "floatPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_score_mat_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_mat_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::score_mat_new", "n_rows, n_cols");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	size_t	n_rows = (size_t)SvUV(ST(0));
	size_t	n_cols = (size_t)SvUV(ST(1));
	Score_mat *	RETVAL;

	RETVAL = score_mat_new(n_rows, n_cols);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Score_matPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_score_mat_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_mat_read)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::score_mat_read", "fname");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	const char *	fname = (const char *)SvPV_nolen(ST(0));
	Score_mat *	RETVAL;

	RETVAL = score_mat_read(fname);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Score_matPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_score_mat_add); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_mat_add)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3 || items > 4)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::score_mat_add", "mat1, mat2, scale, shift = 0.0");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Score_mat *	mat1;
	Score_mat *	mat2;
	float	scale = (float)SvNV(ST(2));
	float	shift;
	Score_mat *	RETVAL;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mat1 = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_mat_add",
			"mat1", "Score_matPtr");

	if (sv_derived_from(ST(1), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    mat2 = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_mat_add",
			"mat2", "Score_matPtr");

	if (items < 4)
	    shift = 0.0;
	else {
	    shift = (float)SvNV(ST(3));
	}

	RETVAL = score_mat_add(mat1, mat2, scale, shift);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Score_matPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_score_mat_info); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_mat_info)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::score_mat_info", "mat");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Score_mat *	mat;
	float	min;
	float	max;
	float	av;
	float	std_dev;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mat = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_mat_info",
			"mat", "Score_matPtr");
#line 472 "Wurst.xs"
        score_mat_info (mat, &min, &max, &av, &std_dev);
#line 1754 "Wurst.c"
	XSprePUSH;	EXTEND(SP,4);
	PUSHs(sv_newmortal());
	sv_setnv(ST(0), (double)min);
	PUSHs(sv_newmortal());
	sv_setnv(ST(1), (double)max);
	PUSHs(sv_newmortal());
	sv_setnv(ST(2), (double)av);
	PUSHs(sv_newmortal());
	sv_setnv(ST(3), (double)std_dev);
    }
    XSRETURN(4);
}


XS(XS_Wurst_score_mat_scale); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_mat_scale)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::score_mat_scale", "mat, scale");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Score_mat *	mat;
	const float	scale = (float)SvNV(ST(1));
	Score_mat *	RETVAL;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mat = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_mat_scale",
			"mat", "Score_matPtr");

	RETVAL = score_mat_scale(mat, scale);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Score_matPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_score_mat_shift); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_mat_shift)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::score_mat_shift", "mat1, shift");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Score_mat *	mat1;
	const float	shift = (float)SvNV(ST(1));
	Score_mat *	RETVAL;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mat1 = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_mat_shift",
			"mat1", "Score_matPtr");

	RETVAL = score_mat_shift(mat1, shift);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Score_matPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_score_mat_write); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_mat_write)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::score_mat_write", "mat1, fname");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Score_mat *	mat1;
	const char *	fname = (const char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mat1 = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_mat_write",
			"mat1", "Score_matPtr");
#line 489 "Wurst.xs"
        RETVAL = score_mat_write (mat1, fname);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 1866 "Wurst.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_score_mat_write_gnuplot); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_mat_write_gnuplot)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::score_mat_write_gnuplot", "smat, fname, protA, protB");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Score_mat *	smat;
	const char *	fname = (const char *)SvPV_nolen(ST(1));
	const char *	protA = (const char *)SvPV_nolen(ST(2));
	const char *	protB = (const char *)SvPV_nolen(ST(3));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    smat = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_mat_write_gnuplot",
			"smat", "Score_matPtr");

	RETVAL = score_mat_write_gnuplot(smat, fname, protA, protB);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_score_mat_diag_wipe); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_mat_diag_wipe)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::score_mat_diag_wipe", "pair_set, smat");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Pair_set *	pair_set;
	Score_mat *	smat;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pair_set = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_mat_diag_wipe",
			"pair_set", "Pair_setPtr");

	if (sv_derived_from(ST(1), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    smat = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_mat_diag_wipe",
			"smat", "Score_matPtr");

	score_mat_diag_wipe(pair_set, smat);
    }
    XSRETURN_EMPTY;
}


XS(XS_Wurst_score_mat_double_matrix); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_mat_double_matrix)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::score_mat_double_matrix", "smat");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Score_mat *	smat;
	Score_mat *	RETVAL;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    smat = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_mat_double_matrix",
			"smat", "Score_matPtr");

	RETVAL = score_mat_double_matrix(smat);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Score_matPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_score_prof_prof); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_prof_prof)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::score_prof_prof", "score_mat, sp1, sp2, subst_matrix");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Score_mat *	score_mat;
	Seqprof *	sp1;
	Seqprof *	sp2;
	Sub_mat *	subst_matrix;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    score_mat = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_prof_prof",
			"score_mat", "Score_matPtr");

	if (sv_derived_from(ST(1), "SeqprofPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    sp1 = INT2PTR(Seqprof *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_prof_prof",
			"sp1", "SeqprofPtr");

	if (sv_derived_from(ST(2), "SeqprofPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    sp2 = INT2PTR(Seqprof *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_prof_prof",
			"sp2", "SeqprofPtr");

	if (sv_derived_from(ST(3), "Sub_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(3)));
	    subst_matrix = INT2PTR(Sub_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_prof_prof",
			"subst_matrix", "Sub_matPtr");
#line 522 "Wurst.xs"
        RETVAL = score_prof_prof (score_mat, sp1, sp2, subst_matrix);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 2039 "Wurst.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_score_smat); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_smat)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::score_smat", "score_mat, seq1, seq2, subst_matrix");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Score_mat *	score_mat;
	Seq *	seq1;
	Seq *	seq2;
	Sub_mat *	subst_matrix;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    score_mat = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_smat",
			"score_mat", "Score_matPtr");

	if (sv_derived_from(ST(1), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    seq1 = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_smat",
			"seq1", "SeqPtr");

	if (sv_derived_from(ST(2), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    seq2 = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_smat",
			"seq2", "SeqPtr");

	if (sv_derived_from(ST(3), "Sub_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(3)));
	    subst_matrix = INT2PTR(Sub_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_smat",
			"subst_matrix", "Sub_matPtr");
#line 537 "Wurst.xs"
        RETVAL = score_smat (score_mat, seq1, seq2, subst_matrix);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 2106 "Wurst.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_score_sprof); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_sprof)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::score_sprof", "score_mat, s_p, seq, subst_matrix");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Score_mat *	score_mat;
	Seqprof *	s_p;
	Seq *	seq;
	Sub_mat *	subst_matrix;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    score_mat = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_sprof",
			"score_mat", "Score_matPtr");

	if (sv_derived_from(ST(1), "SeqprofPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    s_p = INT2PTR(Seqprof *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_sprof",
			"s_p", "SeqprofPtr");

	if (sv_derived_from(ST(2), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    seq = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_sprof",
			"seq", "SeqPtr");

	if (sv_derived_from(ST(3), "Sub_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(3)));
	    subst_matrix = INT2PTR(Sub_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_sprof",
			"subst_matrix", "Sub_matPtr");
#line 552 "Wurst.xs"
        RETVAL = score_sprof (score_mat, s_p, seq, subst_matrix);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 2173 "Wurst.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_score_fx); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_fx)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::score_fx", "score_mat, seq, coord, param");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Score_mat *	score_mat;
	Seq *	seq;
	Coord *	coord;
	FXParam *	param;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    score_mat = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_fx",
			"score_mat", "Score_matPtr");

	if (sv_derived_from(ST(1), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    seq = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_fx",
			"seq", "SeqPtr");

	if (sv_derived_from(ST(2), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    coord = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_fx",
			"coord", "CoordPtr");

	if (sv_derived_from(ST(3), "FXParamPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(3)));
	    param = INT2PTR(FXParam *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_fx",
			"param", "FXParamPtr");
#line 568 "Wurst.xs"
        RETVAL = score_fx (score_mat, seq, coord, param);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 2240 "Wurst.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_score_fx_prof); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_fx_prof)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::score_fx_prof", "score_mat, s_p, coord, param");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Score_mat *	score_mat;
	Seqprof *	s_p;
	Coord *	coord;
	FXParam *	param;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    score_mat = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_fx_prof",
			"score_mat", "Score_matPtr");

	if (sv_derived_from(ST(1), "SeqprofPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    s_p = INT2PTR(Seqprof *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_fx_prof",
			"s_p", "SeqprofPtr");

	if (sv_derived_from(ST(2), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    coord = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_fx_prof",
			"coord", "CoordPtr");

	if (sv_derived_from(ST(3), "FXParamPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(3)));
	    param = INT2PTR(FXParam *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_fx_prof",
			"param", "FXParamPtr");
#line 583 "Wurst.xs"
        RETVAL = score_fx_prof (score_mat, s_p, coord, param);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 2307 "Wurst.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_score_sec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_sec)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::score_sec", "score_mat, sec_s, coord");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Score_mat *	score_mat;
	Sec_s_data *	sec_s;
	Coord *	coord;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    score_mat = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_sec",
			"score_mat", "Score_matPtr");

	if (sv_derived_from(ST(1), "Sec_s_dataPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    sec_s = INT2PTR(Sec_s_data *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_sec",
			"sec_s", "Sec_s_dataPtr");

	if (sv_derived_from(ST(2), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    coord = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_sec",
			"coord", "CoordPtr");
#line 598 "Wurst.xs"
        RETVAL = score_sec (score_mat, sec_s, coord);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 2364 "Wurst.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_param_rs_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_param_rs_read)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::param_rs_read", "fname");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	const char *	fname = (const char *)SvPV_nolen(ST(0));
	RSParam *	RETVAL;

	RETVAL = param_rs_read(fname);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "RSParamPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_score_rs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_rs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::score_rs", "coord, params");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Coord *	coord;
	RSParam *	params;
	float	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    coord = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_rs",
			"coord", "CoordPtr");

	if (sv_derived_from(ST(1), "RSParamPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    params = INT2PTR(RSParam *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_rs",
			"params", "RSParamPtr");

	RETVAL = score_rs(coord, params);
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_param_fx_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_param_fx_read)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::param_fx_read", "fname");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	const char *	fname = (const char *)SvPV_nolen(ST(0));
	FXParam *	RETVAL;

	RETVAL = param_fx_read(fname);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "FXParamPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_RSParamPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_RSParamPtr_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "RSParamPtr::DESTROY", "p");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	RSParam *	p;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    p = INT2PTR(RSParam *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"RSParamPtr::DESTROY",
			"p");
#line 626 "Wurst.xs"
        param_rs_destroy (p);
#line 2483 "Wurst.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_FXParamPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_FXParamPtr_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "FXParamPtr::DESTROY", "f");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	FXParam *	f;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    f = INT2PTR(FXParam *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"FXParamPtr::DESTROY",
			"f");
#line 635 "Wurst.xs"
        FXParam_destroy(f);
#line 2513 "Wurst.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Wurst_score_mat_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_mat_string)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::score_mat_string", "scores, seq0, seq1");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Score_mat *	scores;
	Seq *	seq0;
	Seq *	seq1;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    scores = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_mat_string",
			"scores", "Score_matPtr");

	if (sv_derived_from(ST(1), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    seq0 = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_mat_string",
			"seq0", "SeqPtr");

	if (sv_derived_from(ST(2), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    seq1 = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_mat_string",
			"seq1", "SeqPtr");

	RETVAL = score_mat_string(scores, seq0, seq1);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Wurst_score_mat_sum_full); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_mat_sum_full)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 9 || items > 10)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::score_mat_sum_full", "rmat, scores, pgap_open, pgap_widen, qgap_open, qgap_widen, p_mult, q_mult, align_type, bias_set = NULL");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Score_mat *	rmat;
	Score_mat *	scores;
	float	pgap_open = (float)SvNV(ST(2));
	float	pgap_widen = (float)SvNV(ST(3));
	float	qgap_open = (float)SvNV(ST(4));
	float	qgap_widen = (float)SvNV(ST(5));
	float *	p_mult;
	float *	q_mult;
	int	align_type = (int)SvIV(ST(8));
	Pair_set *	bias_set;
	Pair_set *	RETVAL;

	if (sv_derived_from(ST(1), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    scores = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_mat_sum_full",
			"scores", "Score_matPtr");

	if (sv_derived_from(ST(6), "floatPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(6)));
	    p_mult = INT2PTR(float *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_mat_sum_full",
			"p_mult", "floatPtr");

	if (sv_derived_from(ST(7), "floatPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(7)));
	    q_mult = INT2PTR(float *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_mat_sum_full",
			"q_mult", "floatPtr");

	if (items < 10)
	    bias_set = NULL;
	else {
	    if (sv_derived_from(ST(9), "Pair_setPtr")) {
		IV tmp = SvIV((SV*)SvRV(ST(9)));
		bias_set = INT2PTR(Pair_set *,tmp);
	    }
	    else
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			    "Wurst::score_mat_sum_full",
			    "bias_set", "Pair_setPtr");
	}

	RETVAL = score_mat_sum_full(&rmat, scores, pgap_open, pgap_widen, qgap_open, qgap_widen, p_mult, q_mult, align_type, bias_set);
	sv_setref_pv(ST(0), "Score_matPtr", (void*)rmat);
	SvSETMAGIC(ST(0));
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Pair_setPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_floatPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_floatPtr_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "floatPtr::DESTROY", "f");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	float *	f;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    f = INT2PTR(float *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"floatPtr::DESTROY",
			"f");
#line 668 "Wurst.xs"
       if (f)
           free (f);
#line 2670 "Wurst.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Score_matPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Score_matPtr_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Score_matPtr::DESTROY", "s");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Score_mat *	s;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"Score_matPtr::DESTROY",
			"s");
#line 676 "Wurst.xs"
        score_mat_destroy (s);
#line 2700 "Wurst.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Wurst_pair_set_chimera); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_pair_set_chimera)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::pair_set_chimera", "s, c1, c2");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Pair_set *	s;
	Coord *	c1;
	Coord *	c2;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::pair_set_chimera",
			"s", "Pair_setPtr");

	if (sv_derived_from(ST(1), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    c1 = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::pair_set_chimera",
			"c1", "CoordPtr");

	if (sv_derived_from(ST(2), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    c2 = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::pair_set_chimera",
			"c2", "CoordPtr");

	RETVAL = pair_set_chimera(s, c1, c2);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Wurst_pair_set_coverage); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_pair_set_coverage)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::pair_set_coverage", "s, n1, n2");
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Pair_set *	s;
	size_t	n1 = (size_t)SvUV(ST(1));
	size_t	n2 = (size_t)SvUV(ST(2));

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::pair_set_coverage",
			"s", "Pair_setPtr");
#line 699 "Wurst.xs"
    {
        char *c1, *c2;
        if (pair_set_coverage (s, n1, n2, &c1, &c2) ==  EXIT_FAILURE) {
            free (c1);
            free (c2);
            XSRETURN_UNDEF;
        }
        EXTEND(SP, 2);
        PUSHs(sv_2mortal(newSVpv (c1, 0)));
        PUSHs(sv_2mortal(newSVpv (c2, 0)));
        free (c1);
        free (c2);
    }
#line 2798 "Wurst.c"
	PUTBACK;
	return;
    }
}


XS(XS_Wurst_pair_set_gap); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_pair_set_gap)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::pair_set_gap", "s, open_scale, widen_scale");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Pair_set *	s;
	float	open_cost;
	float	widen_cost;
	float	open_scale = (float)SvNV(ST(1));
	float	widen_scale = (float)SvNV(ST(2));

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::pair_set_gap",
			"s", "Pair_setPtr");
#line 721 "Wurst.xs"
        {
            int i;
            i = pair_set_gap (s, &open_cost, &widen_cost, \
                              open_scale, widen_scale);

            if (i == EXIT_FAILURE)
                XSRETURN_EMPTY;
        }
#line 2840 "Wurst.c"
	XSprePUSH;	EXTEND(SP,2);
	PUSHs(sv_newmortal());
	sv_setnv(ST(0), (double)open_cost);
	PUSHs(sv_newmortal());
	sv_setnv(ST(1), (double)widen_cost);
    }
    XSRETURN(2);
}


XS(XS_Wurst_pair_set_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_pair_set_string)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::pair_set_string", "s, seq0, seq1");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Pair_set *	s;
	Seq *	seq0;
	Seq *	seq1;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::pair_set_string",
			"s", "Pair_setPtr");

	if (sv_derived_from(ST(1), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    seq0 = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::pair_set_string",
			"seq0", "SeqPtr");

	if (sv_derived_from(ST(2), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    seq1 = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::pair_set_string",
			"seq1", "SeqPtr");

	RETVAL = pair_set_string(s, seq0, seq1);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Wurst_multal_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_multal_string)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::multal_string", "s");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Pair_set *	s;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::multal_string",
			"s", "Pair_setPtr");

	RETVAL = multal_string(s);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Wurst_pair_set_pretty_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_pair_set_pretty_string)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3 || items > 5)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::pair_set_pretty_string", "s, seq0, seq1, sec_s_data = NULL, c2 = NULL");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Pair_set *	s;
	Seq *	seq0;
	Seq *	seq1;
	Sec_s_data *	sec_s_data;
	Coord *	c2;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::pair_set_pretty_string",
			"s", "Pair_setPtr");

	if (sv_derived_from(ST(1), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    seq0 = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::pair_set_pretty_string",
			"seq0", "SeqPtr");

	if (sv_derived_from(ST(2), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    seq1 = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::pair_set_pretty_string",
			"seq1", "SeqPtr");

	if (items < 4)
	    sec_s_data = NULL;
	else {
	    if (sv_derived_from(ST(3), "Sec_s_dataPtr")) {
		IV tmp = SvIV((SV*)SvRV(ST(3)));
		sec_s_data = INT2PTR(Sec_s_data *,tmp);
	    }
	    else
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			    "Wurst::pair_set_pretty_string",
			    "sec_s_data", "Sec_s_dataPtr");
	}

	if (items < 5)
	    c2 = NULL;
	else {
	    if (sv_derived_from(ST(4), "CoordPtr")) {
		IV tmp = SvIV((SV*)SvRV(ST(4)));
		c2 = INT2PTR(Coord *,tmp);
	    }
	    else
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			    "Wurst::pair_set_pretty_string",
			    "c2", "CoordPtr");
	}

	RETVAL = pair_set_pretty_string(s, seq0, seq1, sec_s_data, c2);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Wurst_pair_set_get_alignment_indices); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_pair_set_get_alignment_indices)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::pair_set_get_alignment_indices", "p_s, sequencenumber");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Pair_set *	p_s;
	int	sequencenumber = (int)SvIV(ST(1));
	int	start;
	int	stop;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    p_s = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::pair_set_get_alignment_indices",
			"p_s", "Pair_setPtr");
#line 753 "Wurst.xs"
                   pair_set_get_alignment_indices (p_s, sequencenumber, &start, &stop);
#line 3042 "Wurst.c"
	XSprePUSH;	EXTEND(SP,2);
	PUSHs(sv_newmortal());
	sv_setiv(ST(0), (IV)start);
	PUSHs(sv_newmortal());
	sv_setiv(ST(1), (IV)stop);
    }
    XSRETURN(2);
}


XS(XS_Wurst_get_seq_id_simple); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_get_seq_id_simple)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::get_seq_id_simple", "pair_set, s1, s2");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	int	RETVAL;
	dXSTARG;
	Pair_set *	pair_set;
	Seq *	s1;
	Seq *	s2;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pair_set = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::get_seq_id_simple",
			"pair_set", "Pair_setPtr");

	if (sv_derived_from(ST(1), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    s1 = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::get_seq_id_simple",
			"s1", "SeqPtr");

	if (sv_derived_from(ST(2), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    s2 = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::get_seq_id_simple",
			"s2", "SeqPtr");

	RETVAL = get_seq_id_simple(pair_set, s1, s2);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_pair_set_score); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_pair_set_score)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::pair_set_score", "s");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Pair_set *	s;
	float	score;
	float	score_smpl;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::pair_set_score",
			"s", "Pair_setPtr");
#line 765 "Wurst.xs"
        {
            int i;
            i = pair_set_score (s, &score, &score_smpl);

            if (i == EXIT_FAILURE)
                XSRETURN_EMPTY;
        }
#line 3137 "Wurst.c"
	XSprePUSH;	EXTEND(SP,2);
	PUSHs(sv_newmortal());
	sv_setnv(ST(0), (double)score);
	PUSHs(sv_newmortal());
	sv_setnv(ST(1), (double)score_smpl);
    }
    XSRETURN(2);
}


XS(XS_Wurst_pair_set_extend); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_pair_set_extend)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::pair_set_extend", "s, n0, n1, ext_len");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Pair_set *	s;
	size_t	n0 = (size_t)SvUV(ST(1));
	size_t	n1 = (size_t)SvUV(ST(2));
	int	ext_len = (int)SvIV(ST(3));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::pair_set_extend",
			"s", "Pair_setPtr");

	RETVAL = pair_set_extend(s, n0, n1, ext_len);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Pair_setPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Pair_setPtr_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Pair_setPtr::DESTROY", "s");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Pair_set *	s;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"Pair_setPtr::DESTROY",
			"s");
#line 786 "Wurst.xs"
        pair_set_destroy (s);
#line 3207 "Wurst.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Wurst_func_int); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_func_int)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::func_int", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = func_int();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_func_float); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_func_float)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::func_float", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	float	RETVAL;
	dXSTARG;

	RETVAL = func_float();
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_func_char); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_func_char)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::func_char", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	char *	RETVAL;
	dXSTARG;

	RETVAL = func_char();
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Wurst_funcs1_char); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_funcs1_char)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::funcs1_char", "in");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	char *	in = (char *)SvPV_nolen(ST(0));
	char *	RETVAL;
	dXSTARG;

	RETVAL = funcs1_char(in);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Wurst_funcs2_char); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_funcs2_char)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::funcs2_char", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	char *	RETVAL;
	dXSTARG;

	RETVAL = funcs2_char();
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Wurst_free_scratch); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_free_scratch)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::free_scratch", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {

	free_scratch();
    }
    XSRETURN_EMPTY;
}


XS(XS_Wurst_blst_chk_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_blst_chk_read)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::blst_chk_read", "f");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	const char *	f = (const char *)SvPV_nolen(ST(0));
	Seqprof *	RETVAL;

	RETVAL = blst_chk_read(f);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "SeqprofPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_seqprof_str); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_seqprof_str)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::seqprof_str", "p");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Seqprof *	p;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "SeqprofPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    p = INT2PTR(Seqprof *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::seqprof_str",
			"p", "SeqprofPtr");

	RETVAL = seqprof_str(p);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Wurst_seqprof_get_seq); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_seqprof_get_seq)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::seqprof_get_seq", "c");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Seqprof *	c;
	Seq *	RETVAL;

	if (sv_derived_from(ST(0), "SeqprofPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Seqprof *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::seqprof_get_seq",
			"c", "SeqprofPtr");

	RETVAL = seqprof_get_seq(c);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "SeqPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_SeqprofPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_SeqprofPtr_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "SeqprofPtr::DESTROY", "p");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Seqprof *	p;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    p = INT2PTR(Seqprof *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"SeqprofPtr::DESTROY",
			"p");
#line 830 "Wurst.xs"
        seqprof_destroy (p);
#line 3454 "Wurst.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Wurst_scor_set_fromvec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_scor_set_fromvec)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::scor_set_fromvec", "dblvec");
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	AV *	dblvec;
#line 841 "Wurst.xs"
       size_t s=0;
       size_t t;
       SV **d_el, *ssv;
       Scor_set *ss=NULL;
       double *dv;
#line 3481 "Wurst.c"

	if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0)))==SVt_PVAV)
	    dblvec = (AV*)SvRV(ST(0));
	else
	    Perl_croak(aTHX_ "%s: %s is not an array reference",
			"Wurst::scor_set_fromvec",
			"dblvec");
#line 847 "Wurst.xs"
       t = 1+av_len(dblvec);
       if (t>0) {
         dv = malloc(sizeof(*dv)*t); /* vector passed to C function */
         while (s<t) {
           d_el=av_fetch(dblvec, s, 0);
           if (d_el && (SvNIOK(*d_el)))
             /* copy the values from the perl array */
             dv[s] = SvNV( *d_el );
           else
             dv[s] = 0.0; /* and do not complain if */
                         /* we're given garbage   */
           s++;
         }
         ss = scor_set_fromvec( t, dv);
         free(dv);
       }
       if (ss) {
           ssv = sv_newmortal();
           sv_setref_pv(ssv, "Scor_setPtr", (void *)ss);
           EXTEND(SP,1);
           PUSHs(ssv);
       } else {
           XSRETURN_UNDEF;
       }
#line 3514 "Wurst.c"
	PUTBACK;
	return;
    }
}


XS(XS_Wurst_scor_set_to_vec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_scor_set_to_vec)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::scor_set_to_vec", "scoreset");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Scor_set *	scoreset;
#line 880 "Wurst.xs"
          AV *av=Nullav;
          SV *a_el;
          size_t i=0;

#line 3539 "Wurst.c"
	AV *	RETVAL;

	if (sv_derived_from(ST(0), "Scor_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    scoreset = INT2PTR(Scor_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::scor_set_to_vec",
			"scoreset", "Scor_setPtr");
#line 885 "Wurst.xs"
          if (scoreset!=NULL) {
             av = newAV();
             av_unshift(av, scoreset->n);
             while (i<scoreset->n) {
                a_el = sv_newref(newSVnv(scoreset->scores[i]));
                if (av_store(av, i, a_el)==NULL)
                     croak("scor_set_to_vec: av_store returned null - \
 where is my array ???");

                i++;
             }
           }
           RETVAL = av;
#line 3564 "Wurst.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Wurst_scor_set_simpl); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_scor_set_simpl)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::scor_set_simpl", "pairset, scoremat");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Pair_set *	pairset;
	Score_mat *	scoremat;
	Scor_set *	RETVAL;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pairset = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::scor_set_simpl",
			"pairset", "Pair_setPtr");

	if (sv_derived_from(ST(1), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    scoremat = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::scor_set_simpl",
			"scoremat", "Score_matPtr");

	RETVAL = scor_set_simpl(pairset, scoremat);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Scor_setPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_scor_set_scale); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_scor_set_scale)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::scor_set_scale", "scorset, scale");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Scor_set *	scorset;
	float	scale = (float)SvNV(ST(1));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Scor_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    scorset = INT2PTR(Scor_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::scor_set_scale",
			"scorset", "Scor_setPtr");
#line 912 "Wurst.xs"
        RETVAL = scor_set_scale( scorset, scale);
        if (RETVAL == EXIT_FAILURE)
          XSRETURN_UNDEF;
        else
          RETVAL = 1;
#line 3645 "Wurst.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Scor_setPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Scor_setPtr_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Scor_setPtr::DESTROY", "p");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Scor_set *	p;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    p = INT2PTR(Scor_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"Scor_setPtr::DESTROY",
			"p");
#line 927 "Wurst.xs"
        scor_set_destroy (p);
#line 3676 "Wurst.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Wurst_prob_vec_info); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_prob_vec_info)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::prob_vec_info", "pvec");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Prob_vec *	pvec;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Prob_vecPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pvec = INT2PTR(Prob_vec *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::prob_vec_info",
			"pvec", "Prob_vecPtr");

	RETVAL = prob_vec_info(pvec);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Wurst_score_pvec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_pvec)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::score_pvec", "score_mat, pvec1, pvec2");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Score_mat *	score_mat;
	Prob_vec *	pvec1;
	Prob_vec *	pvec2;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    score_mat = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_pvec",
			"score_mat", "Score_matPtr");

	if (sv_derived_from(ST(1), "Prob_vecPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    pvec1 = INT2PTR(Prob_vec *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_pvec",
			"pvec1", "Prob_vecPtr");

	if (sv_derived_from(ST(2), "Prob_vecPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    pvec2 = INT2PTR(Prob_vec *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::score_pvec",
			"pvec2", "Prob_vecPtr");
#line 948 "Wurst.xs"
        RETVAL = score_pvec (score_mat, pvec1, pvec2);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 3764 "Wurst.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_prob_vec_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_prob_vec_size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::prob_vec_size", "pvec");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Prob_vec *	pvec;
	size_t	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Prob_vecPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pvec = INT2PTR(Prob_vec *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::prob_vec_size",
			"pvec", "Prob_vecPtr");

	RETVAL = prob_vec_size(pvec);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_prob_vec_length); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_prob_vec_length)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::prob_vec_length", "pvec");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Prob_vec *	pvec;
	size_t	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Prob_vecPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pvec = INT2PTR(Prob_vec *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::prob_vec_length",
			"pvec", "Prob_vecPtr");

	RETVAL = prob_vec_length(pvec);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_prob_vec_copy); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_prob_vec_copy)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::prob_vec_copy", "pvec");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Prob_vec *	pvec;
	Prob_vec *	RETVAL;

	if (sv_derived_from(ST(0), "Prob_vecPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pvec = INT2PTR(Prob_vec *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::prob_vec_copy",
			"pvec", "Prob_vecPtr");

	RETVAL = prob_vec_copy(pvec);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Prob_vecPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_prob_vec_write); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_prob_vec_write)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::prob_vec_write", "pvec, fname");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Prob_vec *	pvec;
	const char *	fname = (const char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Prob_vecPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pvec = INT2PTR(Prob_vec *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::prob_vec_write",
			"pvec", "Prob_vecPtr");
#line 973 "Wurst.xs"
        RETVAL = prob_vec_write (pvec, fname);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 3898 "Wurst.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_prob_vec_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_prob_vec_read)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::prob_vec_read", "fname");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	const char *	fname = (const char *)SvPV_nolen(ST(0));
	Prob_vec *	RETVAL;

	RETVAL = prob_vec_read(fname);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Prob_vecPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Prob_vecPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Prob_vecPtr_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Prob_vecPtr::DESTROY", "pvec");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Prob_vec *	pvec;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pvec = INT2PTR(Prob_vec *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"Prob_vecPtr::DESTROY",
			"pvec");
#line 991 "Wurst.xs"
        prob_vec_destroy (pvec);
#line 3952 "Wurst.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Wurst_aa_strct_clssfcn_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_aa_strct_clssfcn_read)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::aa_strct_clssfcn_read", "fname, error");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	const char *	fname = (const char *)SvPV_nolen(ST(0));
	const float	error = (float)SvNV(ST(1));
	Aa_strct_clssfcn *	RETVAL;

	RETVAL = aa_strct_clssfcn_read(fname, error);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Aa_strct_clssfcnPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_aa_strct_dump); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_aa_strct_dump)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::aa_strct_dump", "ac");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Aa_strct_clssfcn *	ac;

	if (sv_derived_from(ST(0), "Aa_strct_clssfcnPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ac = INT2PTR(Aa_strct_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::aa_strct_dump",
			"ac", "Aa_strct_clssfcnPtr");

	aa_strct_dump(ac);
    }
    XSRETURN_EMPTY;
}


XS(XS_Wurst_aa_strct_nclass); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_aa_strct_nclass)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::aa_strct_nclass", "ac");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Aa_strct_clssfcn *	ac;
	size_t	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Aa_strct_clssfcnPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ac = INT2PTR(Aa_strct_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::aa_strct_nclass",
			"ac", "Aa_strct_clssfcnPtr");

	RETVAL = aa_strct_nclass(ac);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_aa_strct_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_aa_strct_size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::aa_strct_size", "ac");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Aa_strct_clssfcn *	ac;
	size_t	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Aa_strct_clssfcnPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ac = INT2PTR(Aa_strct_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::aa_strct_size",
			"ac", "Aa_strct_clssfcnPtr");

	RETVAL = aa_strct_size(ac);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_strct_2_prob_vec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_strct_2_prob_vec)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::strct_2_prob_vec", "structure, cmodel, norm = 1");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Coord *	structure;
	Aa_strct_clssfcn *	cmodel;
	int	norm;
	Prob_vec *	RETVAL;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    structure = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::strct_2_prob_vec",
			"structure", "CoordPtr");

	if (sv_derived_from(ST(1), "Aa_strct_clssfcnPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    cmodel = INT2PTR(Aa_strct_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::strct_2_prob_vec",
			"cmodel", "Aa_strct_clssfcnPtr");

	if (items < 3)
	    norm = 1;
	else {
	    norm = (int)SvIV(ST(2));
	}

	RETVAL = strct_2_prob_vec(structure, cmodel, norm);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Prob_vecPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_aa_strct_2_prob_vec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_aa_strct_2_prob_vec)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::aa_strct_2_prob_vec", "structure, cmodel, norm = 1");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Coord *	structure;
	Aa_strct_clssfcn *	cmodel;
	int	norm;
	Prob_vec *	RETVAL;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    structure = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::aa_strct_2_prob_vec",
			"structure", "CoordPtr");

	if (sv_derived_from(ST(1), "Aa_strct_clssfcnPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    cmodel = INT2PTR(Aa_strct_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::aa_strct_2_prob_vec",
			"cmodel", "Aa_strct_clssfcnPtr");

	if (items < 3)
	    norm = 1;
	else {
	    norm = (int)SvIV(ST(2));
	}

	RETVAL = aa_strct_2_prob_vec(structure, cmodel, norm);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Prob_vecPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_prof_aa_strct_2_prob_vec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_prof_aa_strct_2_prob_vec)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3 || items > 4)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::prof_aa_strct_2_prob_vec", "structure, s_p, cmodel, norm = 1");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Coord *	structure;
	Seqprof *	s_p;
	Aa_strct_clssfcn *	cmodel;
	int	norm;
	Prob_vec *	RETVAL;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    structure = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::prof_aa_strct_2_prob_vec",
			"structure", "CoordPtr");

	if (sv_derived_from(ST(1), "SeqprofPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    s_p = INT2PTR(Seqprof *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::prof_aa_strct_2_prob_vec",
			"s_p", "SeqprofPtr");

	if (sv_derived_from(ST(2), "Aa_strct_clssfcnPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    cmodel = INT2PTR(Aa_strct_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::prof_aa_strct_2_prob_vec",
			"cmodel", "Aa_strct_clssfcnPtr");

	if (items < 4)
	    norm = 1;
	else {
	    norm = (int)SvIV(ST(3));
	}

	RETVAL = prof_aa_strct_2_prob_vec(structure, s_p, cmodel, norm);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Prob_vecPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_aa_2_prob_vec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_aa_2_prob_vec)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::aa_2_prob_vec", "seq, cmodel, norm = 1");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Seq *	seq;
	Aa_strct_clssfcn *	cmodel;
	int	norm;
	Prob_vec *	RETVAL;

	if (sv_derived_from(ST(0), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    seq = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::aa_2_prob_vec",
			"seq", "SeqPtr");

	if (sv_derived_from(ST(1), "Aa_strct_clssfcnPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    cmodel = INT2PTR(Aa_strct_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::aa_2_prob_vec",
			"cmodel", "Aa_strct_clssfcnPtr");

	if (items < 3)
	    norm = 1;
	else {
	    norm = (int)SvIV(ST(2));
	}

	RETVAL = aa_2_prob_vec(seq, cmodel, norm);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Prob_vecPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_prof_aa_2_prob_vec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_prof_aa_2_prob_vec)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::prof_aa_2_prob_vec", "s_p, cmodel, norm = 1");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Seqprof *	s_p;
	Aa_strct_clssfcn *	cmodel;
	int	norm;
	Prob_vec *	RETVAL;

	if (sv_derived_from(ST(0), "SeqprofPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s_p = INT2PTR(Seqprof *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::prof_aa_2_prob_vec",
			"s_p", "SeqprofPtr");

	if (sv_derived_from(ST(1), "Aa_strct_clssfcnPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    cmodel = INT2PTR(Aa_strct_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::prof_aa_2_prob_vec",
			"cmodel", "Aa_strct_clssfcnPtr");

	if (items < 3)
	    norm = 1;
	else {
	    norm = (int)SvIV(ST(2));
	}

	RETVAL = prof_aa_2_prob_vec(s_p, cmodel, norm);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Prob_vecPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Aa_strct_clssfcnPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Aa_strct_clssfcnPtr_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Aa_strct_clssfcnPtr::DESTROY", "aa");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Aa_strct_clssfcn *	aa;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    aa = INT2PTR(Aa_strct_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"Aa_strct_clssfcnPtr::DESTROY",
			"aa");
#line 1052 "Wurst.xs"
        aa_strct_clssfcn_destroy (aa);
#line 4354 "Wurst.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Wurst_ac_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_ac_read)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::ac_read", "fname");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	const char *	fname = (const char *)SvPV_nolen(ST(0));
	Aa_clssfcn *	RETVAL;

	RETVAL = ac_read(fname);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Aa_clssfcnPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_ac_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_ac_size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::ac_size", "ac");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Aa_clssfcn *	ac;
	size_t	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Aa_clssfcnPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ac = INT2PTR(Aa_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::ac_size",
			"ac", "Aa_clssfcnPtr");

	RETVAL = ac_size(ac);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_ac_nclass); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_ac_nclass)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::ac_nclass", "ac");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Aa_clssfcn *	ac;
	size_t	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Aa_clssfcnPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ac = INT2PTR(Aa_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::ac_nclass",
			"ac", "Aa_clssfcnPtr");

	RETVAL = ac_nclass(ac);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_ac_dump); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_ac_dump)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::ac_dump", "ac");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Aa_clssfcn *	ac;

	if (sv_derived_from(ST(0), "Aa_clssfcnPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ac = INT2PTR(Aa_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::ac_dump",
			"ac", "Aa_clssfcnPtr");

	ac_dump(ac);
    }
    XSRETURN_EMPTY;
}


XS(XS_Wurst_computeMembershipAAProf); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_computeMembershipAAProf)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::computeMembershipAAProf", "mship, s_p, ac");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	float **	mship;
	Seqprof *	s_p;
	Aa_clssfcn *	ac;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "floatPtrPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mship = INT2PTR(float **,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::computeMembershipAAProf",
			"mship", "floatPtrPtr");

	if (sv_derived_from(ST(1), "SeqprofPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    s_p = INT2PTR(Seqprof *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::computeMembershipAAProf",
			"s_p", "SeqprofPtr");

	if (sv_derived_from(ST(2), "Aa_clssfcnPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    ac = INT2PTR(Aa_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::computeMembershipAAProf",
			"ac", "Aa_clssfcnPtr");
#line 1081 "Wurst.xs"
        RETVAL = computeMembershipAAProf (mship, s_p, ac);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 4526 "Wurst.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_computeMembershipAA); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_computeMembershipAA)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::computeMembershipAA", "mship, seq, ac");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	float **	mship;
	Seq *	seq;
	Aa_clssfcn *	ac;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "floatPtrPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mship = INT2PTR(float **,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::computeMembershipAA",
			"mship", "floatPtrPtr");

	if (sv_derived_from(ST(1), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    seq = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::computeMembershipAA",
			"seq", "SeqPtr");

	if (sv_derived_from(ST(2), "Aa_clssfcnPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    ac = INT2PTR(Aa_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::computeMembershipAA",
			"ac", "Aa_clssfcnPtr");
#line 1095 "Wurst.xs"
        RETVAL = computeMembershipAA (mship, seq, ac);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 4583 "Wurst.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_seq_2_prob_vec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_seq_2_prob_vec)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::seq_2_prob_vec", "seq, ac");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Seq *	seq;
	Aa_clssfcn *	ac;
	Prob_vec *	RETVAL;

	if (sv_derived_from(ST(0), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    seq = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::seq_2_prob_vec",
			"seq", "SeqPtr");

	if (sv_derived_from(ST(1), "Aa_clssfcnPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    ac = INT2PTR(Aa_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::seq_2_prob_vec",
			"ac", "Aa_clssfcnPtr");

	RETVAL = seq_2_prob_vec(seq, ac);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Prob_vecPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Aa_clssfcnPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Aa_clssfcnPtr_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Aa_clssfcnPtr::DESTROY", "aa");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Aa_clssfcn *	aa;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    aa = INT2PTR(Aa_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"Aa_clssfcnPtr::DESTROY",
			"aa");
#line 1113 "Wurst.xs"
        aa_clssfcn_destroy (aa);
#line 4656 "Wurst.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Wurst_find_alt_path_score_simple); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_find_alt_path_score_simple)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::find_alt_path_score_simple", "score_mat, pair_set");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	float	RETVAL;
	dXSTARG;
	Score_mat *	score_mat;
	Pair_set *	pair_set;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    score_mat = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::find_alt_path_score_simple",
			"score_mat", "Score_matPtr");

	if (sv_derived_from(ST(1), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    pair_set = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::find_alt_path_score_simple",
			"pair_set", "Pair_setPtr");

	RETVAL = find_alt_path_score_simple(score_mat, pair_set);
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_get_clssfcn); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_get_clssfcn)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::get_clssfcn", "influence_report_filename, abs_error");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	const char *	influence_report_filename = (const char *)SvPV_nolen(ST(0));
	float	abs_error = (float)SvNV(ST(1));
	Clssfcn *	RETVAL;

	RETVAL = get_clssfcn(influence_report_filename, abs_error);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "ClssfcnPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_computeMembership); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_computeMembership)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::computeMembership", "mship, test_vec, cmodel");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	float *	mship;
	float *	test_vec;
	Clssfcn *	cmodel;
	float *	RETVAL;

	if (sv_derived_from(ST(0), "floatPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mship = INT2PTR(float *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::computeMembership",
			"mship", "floatPtr");

	if (sv_derived_from(ST(1), "floatPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    test_vec = INT2PTR(float *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::computeMembership",
			"test_vec", "floatPtr");

	if (sv_derived_from(ST(2), "ClssfcnPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    cmodel = INT2PTR(Clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::computeMembership",
			"cmodel", "ClssfcnPtr");

	RETVAL = computeMembership(mship, test_vec, cmodel);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "floatPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_ClssfcnPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_ClssfcnPtr_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "ClssfcnPtr::DESTROY", "c");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Clssfcn *	c;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"ClssfcnPtr::DESTROY",
			"c");
#line 1150 "Wurst.xs"
        clssfcn_destroy (c);
#line 4804 "Wurst.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Wurst_merge_alignments); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_merge_alignments)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::merge_alignments", "align1, align2, alignment");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Pair_set *	align1;
	Pair_set *	align2;
	Pair_set *	alignment;
	Pair_set *	RETVAL;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    align1 = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::merge_alignments",
			"align1", "Pair_setPtr");

	if (sv_derived_from(ST(1), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    align2 = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::merge_alignments",
			"align2", "Pair_setPtr");

	if (sv_derived_from(ST(2), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    alignment = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::merge_alignments",
			"alignment", "Pair_setPtr");

	RETVAL = merge_alignments(align1, align2, alignment);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Pair_setPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_pvec_avg); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_pvec_avg)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::pvec_avg", "p_vec1, p_vec2, p_set, cur_step");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Prob_vec *	p_vec1;
	Prob_vec *	p_vec2;
	Pair_set *	p_set;
	int	cur_step = (int)SvIV(ST(3));
	Prob_vec *	RETVAL;

	if (sv_derived_from(ST(0), "Prob_vecPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    p_vec1 = INT2PTR(Prob_vec *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::pvec_avg",
			"p_vec1", "Prob_vecPtr");

	if (sv_derived_from(ST(1), "Prob_vecPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    p_vec2 = INT2PTR(Prob_vec *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::pvec_avg",
			"p_vec2", "Prob_vecPtr");

	if (sv_derived_from(ST(2), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    p_set = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::pvec_avg",
			"p_set", "Pair_setPtr");

	RETVAL = pvec_avg(p_vec1, p_vec2, p_set, cur_step);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Prob_vecPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_remove_seq); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_remove_seq)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::remove_seq", "pairset, index");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Pair_set *	pairset;
	int	index = (int)SvIV(ST(1));
	Pair_set *	RETVAL;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pairset = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::remove_seq",
			"pairset", "Pair_setPtr");

	RETVAL = remove_seq(pairset, index);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Pair_setPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_split_multal); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_split_multal)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::split_multal", "pairset, a, b");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Pair_set *	pairset;
	int	a = (int)SvIV(ST(1));
	int	b = (int)SvIV(ST(2));
	Pair_set *	RETVAL;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pairset = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::split_multal",
			"pairset", "Pair_setPtr");

	RETVAL = split_multal(pairset, a, b);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Pair_setPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Wurst_coord_rmsd); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_rmsd)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::coord_rmsd", "pair_set, coord1, coord2, sub_flag");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Pair_set *	pair_set;
	Coord *	coord1;
	Coord *	coord2;
	int	sub_flag = (int)SvIV(ST(3));
	float	rmsd;
	Coord *	c1_new;
	Coord *	c2_new;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pair_set = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::coord_rmsd",
			"pair_set", "Pair_setPtr");

	if (sv_derived_from(ST(1), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    coord1 = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::coord_rmsd",
			"coord1", "CoordPtr");

	if (sv_derived_from(ST(2), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    coord2 = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::coord_rmsd",
			"coord2", "CoordPtr");
#line 1191 "Wurst.xs"
        {
            int i;
            i = coord_rmsd(pair_set, coord1, coord2, sub_flag, &rmsd, &c1_new, &c2_new);
            if (i == EXIT_FAILURE)
                XSRETURN_EMPTY;
        }
#line 5035 "Wurst.c"
	XSprePUSH;	EXTEND(SP,3);
	PUSHs(sv_newmortal());
	sv_setnv(ST(0), (double)rmsd);
	PUSHs(sv_newmortal());
	sv_setref_pv(ST(1), "CoordPtr", (void*)c1_new);
	PUSHs(sv_newmortal());
	sv_setref_pv(ST(2), "CoordPtr", (void*)c2_new);
    }
    XSRETURN(3);
}


XS(XS_Wurst_get_rmsd); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_get_rmsd)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::get_rmsd", "pairset, r1, r2");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Pair_set *	pairset;
	Coord *	r1;
	Coord *	r2;
	float	rmsd;
	int	count;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pairset = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::get_rmsd",
			"pairset", "Pair_setPtr");

	if (sv_derived_from(ST(1), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    r1 = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::get_rmsd",
			"r1", "CoordPtr");

	if (sv_derived_from(ST(2), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    r2 = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::get_rmsd",
			"r2", "CoordPtr");
#line 1203 "Wurst.xs"
        {
            int i;
            i = get_rmsd(pairset, r1, r2, &rmsd, &count);
            if (i == EXIT_FAILURE)
                XSRETURN_EMPTY;
        }
#line 5099 "Wurst.c"
	XSprePUSH;	EXTEND(SP,2);
	PUSHs(sv_newmortal());
	sv_setnv(ST(0), (double)rmsd);
	PUSHs(sv_newmortal());
	sv_setiv(ST(1), (IV)count);
    }
    XSRETURN(2);
}


XS(XS_Wurst_get_compound_coord); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_get_compound_coord)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::get_compound_coord", "c");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Coord *	c;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::get_compound_coord",
			"c", "CoordPtr");

	RETVAL = get_compound_coord(c);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Wurst_get_compound_vec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_get_compound_vec)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Wurst::get_compound_vec", "v");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Prob_vec *	v;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Prob_vecPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    v = INT2PTR(Prob_vec *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Wurst::get_compound_vec",
			"v", "Prob_vecPtr");

	RETVAL = get_compound_vec(v);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Wurst); /* prototype to pass -Wmissing-prototypes */
XS(boot_Wurst)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    char* file = __FILE__;

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        newXSproto("Wurst::constant", XS_Wurst_constant, file, "$$");
        newXSproto("Wurst::sec_s_data_read", XS_Wurst_sec_s_data_read, file, "$");
        newXSproto("Wurst::sec_s_data_string", XS_Wurst_sec_s_data_string, file, "$");
        newXSproto("Sec_s_dataPtr::DESTROY", XS_Sec_s_dataPtr_DESTROY, file, "$");
        newXSproto("Wurst::seq_read", XS_Wurst_seq_read, file, "$");
        newXSproto("Wurst::seq_from_string", XS_Wurst_seq_from_string, file, "$");
        newXSproto("Wurst::seq_get_1", XS_Wurst_seq_get_1, file, "$$");
        newXSproto("Wurst::seq_num", XS_Wurst_seq_num, file, "$");
        newXSproto("Wurst::seq_size", XS_Wurst_seq_size, file, "$");
        newXSproto("Wurst::seq_print", XS_Wurst_seq_print, file, "$");
        newXSproto("Wurst::seq_read_many", XS_Wurst_seq_read_many, file, "$;$");
        newXSproto("Wurst::seq_print_many", XS_Wurst_seq_print_many, file, "$");
        newXSproto("SeqPtr::DESTROY", XS_SeqPtr_DESTROY, file, "$");
        newXSproto("Seq_arrayPtrPtr::DESTROY", XS_Seq_arrayPtrPtr_DESTROY, file, "$");
        newXSproto("Wurst::sub_mat_read", XS_Wurst_sub_mat_read, file, "$");
        newXSproto("Wurst::sub_mat_string", XS_Wurst_sub_mat_string, file, "$");
        newXSproto("Wurst::sub_mat_shift", XS_Wurst_sub_mat_shift, file, "$$");
        newXSproto("Wurst::sub_mat_scale", XS_Wurst_sub_mat_scale, file, "$$$");
        newXSproto("Wurst::sub_mat_get_by_i", XS_Wurst_sub_mat_get_by_i, file, "$$$");
        newXSproto("Wurst::sub_mat_get_by_c", XS_Wurst_sub_mat_get_by_c, file, "$$$");
        newXSproto("Wurst::sub_mat_set_by_i", XS_Wurst_sub_mat_set_by_i, file, "$$$$");
        newXSproto("Wurst::sub_mat_set_by_c", XS_Wurst_sub_mat_set_by_c, file, "$$$$");
        newXSproto("Sub_matPtr::DESTROY", XS_Sub_matPtr_DESTROY, file, "$");
        newXSproto("Wurst::coord_2_bin", XS_Wurst_coord_2_bin, file, "$$");
        newXSproto("Wurst::coord_name", XS_Wurst_coord_name, file, "$");
        newXSproto("Wurst::coord_size", XS_Wurst_coord_size, file, "$");
        newXSproto("Wurst::coord_read", XS_Wurst_coord_read, file, "$");
        newXSproto("Wurst::coord_get_seq", XS_Wurst_coord_get_seq, file, "$");
        newXSproto("Wurst::coord_has_sec_s", XS_Wurst_coord_has_sec_s, file, "$");
        newXSproto("Wurst::coord_get_sec_s", XS_Wurst_coord_get_sec_s, file, "$");
        newXSproto("Wurst::coord_2_pdb", XS_Wurst_coord_2_pdb, file, "$$;$");
        newXSproto("Wurst::coord_2_spdb", XS_Wurst_coord_2_spdb, file, "$$$;$");
        newXSproto("Wurst::coord_c_n_dist", XS_Wurst_coord_c_n_dist, file, "$$$$");
        newXSproto("Wurst::coord_calc_psi", XS_Wurst_coord_calc_psi, file, "$");
        newXSproto("Wurst::coord_calc_phi", XS_Wurst_coord_calc_phi, file, "$");
        newXSproto("Wurst::coord_psi", XS_Wurst_coord_psi, file, "$$$");
        newXSproto("Wurst::coord_phi", XS_Wurst_coord_phi, file, "$$$");
        newXSproto("Wurst::coord_geo_gap", XS_Wurst_coord_geo_gap, file, "$$$");
        newXSproto("Wurst::dme_thresh", XS_Wurst_dme_thresh, file, "$$$$");
        newXSproto("Wurst::pdb_read", XS_Wurst_pdb_read, file, "$$$");
        newXSproto("CoordPtr::DESTROY", XS_CoordPtr_DESTROY, file, "$");
        newXSproto("Wurst::make_model", XS_Wurst_make_model, file, "$$$");
        newXSproto("Wurst::model_pdb_num", XS_Wurst_model_pdb_num, file, "$$");
        newXSproto("Wurst::model_res_num", XS_Wurst_model_res_num, file, "$$");
        newXSproto("Wurst::coord_2_pnlty", XS_Wurst_coord_2_pnlty, file, "$$");
        newXSproto("Wurst::score_mat_new", XS_Wurst_score_mat_new, file, "$$");
        newXSproto("Wurst::score_mat_read", XS_Wurst_score_mat_read, file, "$");
        newXSproto("Wurst::score_mat_add", XS_Wurst_score_mat_add, file, "$$$;$");
        newXSproto("Wurst::score_mat_info", XS_Wurst_score_mat_info, file, "$");
        newXSproto("Wurst::score_mat_scale", XS_Wurst_score_mat_scale, file, "$$");
        newXSproto("Wurst::score_mat_shift", XS_Wurst_score_mat_shift, file, "$$");
        newXSproto("Wurst::score_mat_write", XS_Wurst_score_mat_write, file, "$$");
        newXSproto("Wurst::score_mat_write_gnuplot", XS_Wurst_score_mat_write_gnuplot, file, "$$$$");
        newXSproto("Wurst::score_mat_diag_wipe", XS_Wurst_score_mat_diag_wipe, file, "$$");
        newXSproto("Wurst::score_mat_double_matrix", XS_Wurst_score_mat_double_matrix, file, "$");
        newXSproto("Wurst::score_prof_prof", XS_Wurst_score_prof_prof, file, "$$$$");
        newXSproto("Wurst::score_smat", XS_Wurst_score_smat, file, "$$$$");
        newXSproto("Wurst::score_sprof", XS_Wurst_score_sprof, file, "$$$$");
        newXSproto("Wurst::score_fx", XS_Wurst_score_fx, file, "$$$$");
        newXSproto("Wurst::score_fx_prof", XS_Wurst_score_fx_prof, file, "$$$$");
        newXSproto("Wurst::score_sec", XS_Wurst_score_sec, file, "$$$");
        newXSproto("Wurst::param_rs_read", XS_Wurst_param_rs_read, file, "$");
        newXSproto("Wurst::score_rs", XS_Wurst_score_rs, file, "$$");
        newXSproto("Wurst::param_fx_read", XS_Wurst_param_fx_read, file, "$");
        newXSproto("RSParamPtr::DESTROY", XS_RSParamPtr_DESTROY, file, "$");
        newXSproto("FXParamPtr::DESTROY", XS_FXParamPtr_DESTROY, file, "$");
        newXSproto("Wurst::score_mat_string", XS_Wurst_score_mat_string, file, "$$$");
        newXSproto("Wurst::score_mat_sum_full", XS_Wurst_score_mat_sum_full, file, "$$$$$$$$$;$");
        newXSproto("floatPtr::DESTROY", XS_floatPtr_DESTROY, file, "$");
        newXSproto("Score_matPtr::DESTROY", XS_Score_matPtr_DESTROY, file, "$");
        newXSproto("Wurst::pair_set_chimera", XS_Wurst_pair_set_chimera, file, "$$$");
        newXSproto("Wurst::pair_set_coverage", XS_Wurst_pair_set_coverage, file, "$$$");
        newXSproto("Wurst::pair_set_gap", XS_Wurst_pair_set_gap, file, "$$$");
        newXSproto("Wurst::pair_set_string", XS_Wurst_pair_set_string, file, "$$$");
        newXSproto("Wurst::multal_string", XS_Wurst_multal_string, file, "$");
        newXSproto("Wurst::pair_set_pretty_string", XS_Wurst_pair_set_pretty_string, file, "$$$;$$");
        newXSproto("Wurst::pair_set_get_alignment_indices", XS_Wurst_pair_set_get_alignment_indices, file, "$$");
        newXSproto("Wurst::get_seq_id_simple", XS_Wurst_get_seq_id_simple, file, "$$$");
        newXSproto("Wurst::pair_set_score", XS_Wurst_pair_set_score, file, "$");
        newXSproto("Wurst::pair_set_extend", XS_Wurst_pair_set_extend, file, "$$$$");
        newXSproto("Pair_setPtr::DESTROY", XS_Pair_setPtr_DESTROY, file, "$");
        newXSproto("Wurst::func_int", XS_Wurst_func_int, file, "");
        newXSproto("Wurst::func_float", XS_Wurst_func_float, file, "");
        newXSproto("Wurst::func_char", XS_Wurst_func_char, file, "");
        newXSproto("Wurst::funcs1_char", XS_Wurst_funcs1_char, file, "$");
        newXSproto("Wurst::funcs2_char", XS_Wurst_funcs2_char, file, "");
        newXSproto("Wurst::free_scratch", XS_Wurst_free_scratch, file, "");
        newXSproto("Wurst::blst_chk_read", XS_Wurst_blst_chk_read, file, "$");
        newXSproto("Wurst::seqprof_str", XS_Wurst_seqprof_str, file, "$");
        newXSproto("Wurst::seqprof_get_seq", XS_Wurst_seqprof_get_seq, file, "$");
        newXSproto("SeqprofPtr::DESTROY", XS_SeqprofPtr_DESTROY, file, "$");
        newXSproto("Wurst::scor_set_fromvec", XS_Wurst_scor_set_fromvec, file, "$");
        newXSproto("Wurst::scor_set_to_vec", XS_Wurst_scor_set_to_vec, file, "$");
        newXSproto("Wurst::scor_set_simpl", XS_Wurst_scor_set_simpl, file, "$$");
        newXSproto("Wurst::scor_set_scale", XS_Wurst_scor_set_scale, file, "$$");
        newXSproto("Scor_setPtr::DESTROY", XS_Scor_setPtr_DESTROY, file, "$");
        newXSproto("Wurst::prob_vec_info", XS_Wurst_prob_vec_info, file, "$");
        newXSproto("Wurst::score_pvec", XS_Wurst_score_pvec, file, "$$$");
        newXSproto("Wurst::prob_vec_size", XS_Wurst_prob_vec_size, file, "$");
        newXSproto("Wurst::prob_vec_length", XS_Wurst_prob_vec_length, file, "$");
        newXSproto("Wurst::prob_vec_copy", XS_Wurst_prob_vec_copy, file, "$");
        newXSproto("Wurst::prob_vec_write", XS_Wurst_prob_vec_write, file, "$$");
        newXSproto("Wurst::prob_vec_read", XS_Wurst_prob_vec_read, file, "$");
        newXSproto("Prob_vecPtr::DESTROY", XS_Prob_vecPtr_DESTROY, file, "$");
        newXSproto("Wurst::aa_strct_clssfcn_read", XS_Wurst_aa_strct_clssfcn_read, file, "$$");
        newXSproto("Wurst::aa_strct_dump", XS_Wurst_aa_strct_dump, file, "$");
        newXSproto("Wurst::aa_strct_nclass", XS_Wurst_aa_strct_nclass, file, "$");
        newXSproto("Wurst::aa_strct_size", XS_Wurst_aa_strct_size, file, "$");
        newXSproto("Wurst::strct_2_prob_vec", XS_Wurst_strct_2_prob_vec, file, "$$;$");
        newXSproto("Wurst::aa_strct_2_prob_vec", XS_Wurst_aa_strct_2_prob_vec, file, "$$;$");
        newXSproto("Wurst::prof_aa_strct_2_prob_vec", XS_Wurst_prof_aa_strct_2_prob_vec, file, "$$$;$");
        newXSproto("Wurst::aa_2_prob_vec", XS_Wurst_aa_2_prob_vec, file, "$$;$");
        newXSproto("Wurst::prof_aa_2_prob_vec", XS_Wurst_prof_aa_2_prob_vec, file, "$$;$");
        newXSproto("Aa_strct_clssfcnPtr::DESTROY", XS_Aa_strct_clssfcnPtr_DESTROY, file, "$");
        newXSproto("Wurst::ac_read", XS_Wurst_ac_read, file, "$");
        newXSproto("Wurst::ac_size", XS_Wurst_ac_size, file, "$");
        newXSproto("Wurst::ac_nclass", XS_Wurst_ac_nclass, file, "$");
        newXSproto("Wurst::ac_dump", XS_Wurst_ac_dump, file, "$");
        newXSproto("Wurst::computeMembershipAAProf", XS_Wurst_computeMembershipAAProf, file, "$$$");
        newXSproto("Wurst::computeMembershipAA", XS_Wurst_computeMembershipAA, file, "$$$");
        newXSproto("Wurst::seq_2_prob_vec", XS_Wurst_seq_2_prob_vec, file, "$$");
        newXSproto("Aa_clssfcnPtr::DESTROY", XS_Aa_clssfcnPtr_DESTROY, file, "$");
        newXSproto("Wurst::find_alt_path_score_simple", XS_Wurst_find_alt_path_score_simple, file, "$$");
        newXSproto("Wurst::get_clssfcn", XS_Wurst_get_clssfcn, file, "$$");
        newXSproto("Wurst::computeMembership", XS_Wurst_computeMembership, file, "$$$");
        newXSproto("ClssfcnPtr::DESTROY", XS_ClssfcnPtr_DESTROY, file, "$");
        newXSproto("Wurst::merge_alignments", XS_Wurst_merge_alignments, file, "$$$");
        newXSproto("Wurst::pvec_avg", XS_Wurst_pvec_avg, file, "$$$$");
        newXSproto("Wurst::remove_seq", XS_Wurst_remove_seq, file, "$$");
        newXSproto("Wurst::split_multal", XS_Wurst_split_multal, file, "$$$");
        newXSproto("Wurst::coord_rmsd", XS_Wurst_coord_rmsd, file, "$$$$");
        newXSproto("Wurst::get_rmsd", XS_Wurst_get_rmsd, file, "$$$");
        newXSproto("Wurst::get_compound_coord", XS_Wurst_get_compound_coord, file, "$");
        newXSproto("Wurst::get_compound_vec", XS_Wurst_get_compound_vec, file, "$");
    if (PL_unitcheckav)
         call_list(PL_scopestack_ix, PL_unitcheckav);
    XSRETURN_YES;
}

