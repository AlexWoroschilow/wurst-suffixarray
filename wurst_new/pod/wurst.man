.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "WURST 1"
.TH WURST 1 "2007-06-28" "perl v5.8.6" "User Contributed Perl Documentation"
.SH "NAME"
wurst \- wonderful universal remedial structure terminator
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBperl\fR \fIscript_file\fR
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Vb 1
\&    use Wurst;
.Ve
.PP
or, depending on the directory you are running from,
.PP
.Vb 4
\&    use FindBin;
\&    use lib "$FindBin::Bin/../src/Wurst/blib/arch";
\&    use lib "$FindBin::Bin/../src/Wurst/blib/lib";
\&    use Wurst;
.Ve
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
This program does sequence to sequence or structure alignments
and might do things like rank the consequent models.
.PP
The philosophy is that there is a set of low level routines
coded in C. These are called from perl. To do anything useful,
you write a little perl script which calls the functions you want.
.SH "DATA TYPES"
.IX Header "DATA TYPES"
We define certain kinds of pieces of data. In general, the
interpreter calls a function which returns a pointer to some
piece of data with a label. This may be passed into other
function calls. When the last reference to the piece of data
disappears, the object will be cleared up.
.PP
For example, \f(CW\*(C`seq_read()\*(C'\fR returns something of type
SeqPtr. This can then be passed to other functions like
\&\f(CW\*(C`make_model()\*(C'\fR.
.PP
The scheme is such that we have some kind of type
checking.
For example, make_model has an interface like
.PP
.Vb 1
\& make_model ( p, seq, coord)
.Ve
.PP
and the interpreter will only make the call if the first
argument is a Pair_set, the second a sequence and the third
some coordinates.
.PP
The set of data types includes:
.IP "Aa_clssfcn" 4
.IX Item "Aa_clssfcn"
.PD 0
.IP "Clssfcn" 4
.IX Item "Clssfcn"
.IP "Coord" 4
.IX Item "Coord"
.IP "Dpt_list" 4
.IX Item "Dpt_list"
.IP "FXParam" 4
.IX Item "FXParam"
.IP "Pair_set" 4
.IX Item "Pair_set"
.IP "Param" 4
.IX Item "Param"
.IP "Prob_vec" 4
.IX Item "Prob_vec"
.IP "Sec_s_data" 4
.IX Item "Sec_s_data"
.IP "Seq" 4
.IX Item "Seq"
.IP "Seq_array" 4
.IX Item "Seq_array"
.IP "Sub_mat" 4
.IX Item "Sub_mat"
.IP "Score_mat" 4
.IX Item "Score_mat"
.IP "Scor_set" 4
.IX Item "Scor_set"
.IP "Seqprof" 4
.IX Item "Seqprof"
.PD
.SH "PROBABILITY VECTOR NOTES"
.IX Header "PROBABILITY VECTOR NOTES"
This is a special section to point one in the right direction to
read about the functions which create probability vectors. These
are (will be) described in the full function list, but they can
be hard to find, so they are gathered together here.
.IP "seq_2_prob_vec" 4
.IX Item "seq_2_prob_vec"
Create a probability vector from a sequence structure, using a
classification that is purely sequence based.
.IP "struct_2_prob_vec" 4
.IX Item "struct_2_prob_vec"
Create a probability vector from a structure, using a
classification that is purely sequence based.
.IP "aa_strct_2_prob_vec" 4
.IX Item "aa_strct_2_prob_vec"
Create a probability vector from a structure, but using a
classification based on sequence and structure information.
Use both the sequence and structure data.
.IP "aa_2_prob_vec" 4
.IX Item "aa_2_prob_vec"
Create a probability vector from a sequence, but using a
classification based on sequence and structure information. This
is the same classification as above in \f(CW\*(C`aa_strct_2_prob_vec\*(C'\fR.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "ac_nclass \s-1AA_CLSSFCN\s0" 4
.IX Item "ac_nclass AA_CLSSFCN"
\&\fB\s-1AA_CLSSFCN\s0\fR is an amino acid fragment classification. Return
the number of classes in the classification.
.IP "ac_dump \s-1AA_CLSSFCN\s0 \fB\s-1AA_CLSSFCN\s0\fR is an amino acid fragment classfication. Print some information to stdout about the classication. This is really a placeholder. The information printed is not very comprehensive." 4
.IX Item "ac_dump AA_CLSSFCN AA_CLSSFCN is an amino acid fragment classfication. Print some information to stdout about the classication. This is really a placeholder. The information printed is not very comprehensive."
.PD 0
.IP "ac_nclass \s-1AA_CLSSFCN\s0 \fB\s-1AA_CLSSFCN\s0\fR is an amino acid fragment classfication. Return the number of classes." 4
.IX Item "ac_nclass AA_CLSSFCN AA_CLSSFCN is an amino acid fragment classfication. Return the number of classes."
.IP "ac_size \s-1AA_CLSSFCN\s0 \fB\s-1AA_CLSSFCN\s0\fR is an amino acid fragment classfication. Return the fragment length. The intention is only simple for the case of sequence classes. For structural classifications, there may be more than \fIN\fR descriptors for \fIN\fR residues." 4
.IX Item "ac_size AA_CLSSFCN AA_CLSSFCN is an amino acid fragment classfication. Return the fragment length. The intention is only simple for the case of sequence classes. For structural classifications, there may be more than N descriptors for N residues."
.IP "ac_read \s-1FNAME\s0" 4
.IX Item "ac_read FNAME"
.PD
Read an amino acid fragment classification.
Return a \fBAa_clssfcn\fR object if successful, undef otherwise.
.IP "ac_size \s-1AA_CLSSFCN\s0 \fB\s-1AA_CLSSFCN\s0\fR is an amino acid fragment classification. Return the fragment size used in the classification." 4
.IX Item "ac_size AA_CLSSFCN AA_CLSSFCN is an amino acid fragment classification. Return the fragment size used in the classification."
.PD 0
.IP "blst_chk_read \s-1FNAME\s0" 4
.IX Item "blst_chk_read FNAME"
.PD
Read a \s-1BLAST\s0 checkpoint file from \fB\s-1FNAME\s0\fR. Return a \fBSeqprof\fR
object if successful, undef otherwise.
.IP "blst_chk_write \s-1FNAME\s0 Seqprof" 4
.IX Item "blst_chk_write FNAME Seqprof"
Writes a \s-1BLAST\s0 checkpoint file to \fB\s-1FNAME\s0\fR. Returns 1 if successful,
and 0 otherwise. This profile is functionally equivalent to profiles
written by psi-blast and used by wurst, but not byte-equivalent (due
to floating point noise).
.IP "get_clssfcn \s-1FNAME\s0 abs_error Reads an classification generated by AutoClass\-C. Do not forget to give an absolut error value from your original data (it will be used for the integration in \fIcomputeMembership()\fR ). Returns a \fBClssfcn\fR object if successful, undef otherwise." 4
.IX Item "get_clssfcn FNAME abs_error Reads an classification generated by AutoClass-C. Do not forget to give an absolut error value from your original data (it will be used for the integration in computeMembership() ). Returns a Clssfcn object if successful, undef otherwise."
.PD 0
.IP "coord_2_bin \s-1COORD\s0 \s-1FNAME\s0" 4
.IX Item "coord_2_bin COORD FNAME"
.PD
Take a \fBCoord\fR structure and write it, in our proprietary .bin
format, to \s-1FNAME\s0.  Returns 1 on success and undef on failure.
.Sp
This function may be used when writing the results of a
calculation, but more likely, it is used when converting \s-1PDB\s0
files to our \f(CW\*(C`.bin\*(C'\fR format. Look at pdb_read.
.IP "coord_c_n_dist \s-1COORD\s0 i, j, sqrt_flag" 4
.IX Item "coord_c_n_dist COORD i, j, sqrt_flag"
Given a \fBCoord\fR structure, \s-1COORD\s0 and the index of two residues,
\&\fBi\fR and \fBj\fR return the distance, in Angstroms between the
carbonyl oxygen of \fBi\fR and the backbone nitrogen atom of
\&\fBj\fR if \fBsqrt_flag\fR is set to non\-zero. If the flag is left as
zero or \fBundef\fR, then the value returned will be the distance
squared.
.Sp
In a protein, the bondlength is about 1.32 Angstrom. Many scripts
just want to check for continuous chains, so they do not need the
real distance and it is faster to avoid the square root. For
example, to check if the third and fourth residues are bonded,
you might say
.Sp
.Vb 6
\&    my $dist2 = 1.5 * 1.5;
\&    if (coord_c_n_dist ($coord, 2, 3, 0) > $dist2) {
\&        print "not connected\en";
\&    } else {
\&        print "connected\en";
\&    }
.Ve
.IP "coord_deletion \s-1COORD\s0 Start Coord_Length Seq_Length" 4
.IX Item "coord_deletion COORD Start Coord_Length Seq_Length"
Returns a pointer to a new \fBCoord\fR (structure) where an
affine gap has been introduced, arising from the deletion
of some sequence or coordinate data from an existing structure.
The gap is specified by its \fBStart\fR [0,size), and number
of residues excised from the structure (\fBCoord_Length\fR)
and sequence (\fBSeq_Length\fR).
.Sp
Minimal checking ensures gap specifications are sensible.
This function is provided for the generation of synthetic
threading results and other forms of improper structure
sets.
.IP "coord_geo_gap \s-1COORD\s0 \s-1SCALE\s0 \s-1MAX\s0" 4
.IX Item "coord_geo_gap COORD SCALE MAX"
Calculate a penalty based on the geometric damage in a
structure. This is based on the carbonyl carbon to amide nitrogen
distance between each pair of residues which should be
connected. The ideal C..N distance is 1.32 Angstrom. No penalty
is enforced if the distance is less than 2.0 Angstrom.
\&\s-1COORD\s0 is a set of coordinates.  \s-1SCALE\s0 is the number
with which penalties will be multiplied.  \s-1MAX\s0 is a limit on the
distance to be considered. For each gap, if it is bigger than
\&\s-1MAX\s0, it is set to \s-1MAX\s0.
.Sp
This function returns a list of values like:
.Sp
.Vb 2
\& ($quadratic, $linear, $logistic, $num_gap)
\&              = coord_geo_gap ($coord, $scale, $max);
.Ve
.Sp
Where
.RS 4
.IP "$quadratic" 4
.IX Item "$quadratic"
Sum over (distance \- ideal)^2 for each gap, where ideal is hard
coded to about 1.32 Angstrom.
.IP "$linear" 4
.IX Item "$linear"
This is the sum over (distance \- ideal) for each gap.
.IP "$logistic" 4
.IX Item "$logistic"
This uses a logistic activation function. The penalty is the sum
of a fancy logistic activation function applied to each gap.
.IP "$num_gap" 4
.IX Item "$num_gap"
This is the number of gaps, regardless of length.
.RE
.RS 4
.RE
.IP "coord_get_seq \s-1COORD\s0" 4
.IX Item "coord_get_seq COORD"
Returns a pointer to a \fBSeq\fR (sequence) given a pointer to a
\&\fBCoord\fR.
.IP "coord_has_sec_s \s-1COORD\s0" 4
.IX Item "coord_has_sec_s COORD"
Returns non-zero if \fB\s-1COORD\s0\fR has defined secondary structure.
.IP "coord_get_sec_s \s-1COORD\s0" 4
.IX Item "coord_get_sec_s COORD"
Returns a string containing the secondary structure assignment
for the coordinates, if they exist. Side\-effect: a non-serious
warning message is generated if \s-1COORD\s0 has no assigned secondary
structure.
.IP "coord_name \s-1COORD\s0" 4
.IX Item "coord_name COORD"
Print the \s-1PDB\s0 acquisition code and chain identifier from the
coordinates, \s-1COORD\s0 (an object of \f(CW\*(C`Coord\*(C'\fR type).
.IP "coord_read \s-1FNAME\s0" 4
.IX Item "coord_read FNAME"
Read coordinates from file \s-1FNAME\s0. Returns a \fBCoord\fR pointer.
.IP "coord_rmsd \s-1PAIR_SET\s0, \s-1COORD1\s0, \s-1COORD2\s0, \s-1SUBSET_FLAG\s0" 4
.IX Item "coord_rmsd PAIR_SET, COORD1, COORD2, SUBSET_FLAG"
.PD 0
.IP "coord_rmsd \s-1PAIR_SET\s0, \s-1COORD1\s0, \s-1COORD2\s0" 4
.IX Item "coord_rmsd PAIR_SET, COORD1, COORD2"
.PD
Superimpose \s-1COORD1\s0 onto \s-1COORD2\s0 and calculate the root mean square
difference of coordinates in Angstroms, based on an alignment. Return
a list with shifted coordinates and the rmsd value like this
.Sp
.Vb 1
\&  ($rmsd, $new_c1, $new_c2) = rmsd ($pair_set, $c1, $c2)
.Ve
.Sp
or
.Sp
.Vb 1
\&  ($rmsd, $new_c1, $new_c2) = rmsd ($pair_set, $c1, $c2, SUBSET_FLAG)
.Ve
.Sp
$rmsd is the root mean square difference. \f(CW$new_c1\fR is a coordinate
object which has been moved. It may be smaller than \f(CW$c1\fR (see note
below about \s-1SUBSET_FLAG\s0). \f(CW$new_c2\fR may be identical to \f(CW$c2\fR.
.Sp
$pair_set has come from some kind of alignment such as sequence to
sequence or structure to structure. \f(CW$c1\fR are the coordinates to be
moved. \f(CW$c2\fR are the reference coordinates. If defined, the optional
argument, \s-1SUBSET_FLAG\s0, means that one walks down the list coordinates
of \f(CW$c1\fR and \f(CW$c2\fR and copies into \f(CW$new_c1\fR and \f(CW$new_c2\fR those
sites which were aligned.
.Sp
If the alignment of two proteins includes most of the original
coordinates, then one will not usually want to define \s-1SUBSET_FLAG\s0. If
the two proteins are very different sizes, it makes sense to define
this flag (and only see the similar regions).
If \s-1SUBSET_FLAG\s0 is not set, \f(CW$new_c2\fR is an exact copy of \f(CW$c2\fR.
.IP "coord_size \s-1COORD\s0" 4
.IX Item "coord_size COORD"
Return an integer with the number of residues in \s-1COORD\s0, a
\&\f(CW\*(C`Coord\*(C'\fR object.
.IP "coord_2_pdb \s-1FNAME\s0 \s-1COORD\s0 \s-1SEQ\s0" 4
.IX Item "coord_2_pdb FNAME COORD SEQ"
.PD 0
.IP "coord_2_pdb \s-1FNAME\s0 \s-1COORD\s0" 4
.IX Item "coord_2_pdb FNAME COORD"
.PD
Write the coordinates from \s-1COORD\s0 (a \fBCoord\fR pointer) to the
filename given by \s-1FNAME\s0. Returns nonzero on success and the
undefined value otherwise.
.Sp
If the optional last argument, \s-1SEQ\s0, is present, it should be a
sequence object and will be used to print the original
(hopefully) complete sequence in the pdb file in standard, \s-1PDB\s0,
\&\s-1SEQRES\s0 format records.
.IP "coord_2_spdb \s-1FNAME\s0 \s-1COORD\s0 \s-1SCOR_SET\s0" 4
.IX Item "coord_2_spdb FNAME COORD SCOR_SET"
.PD 0
.IP "coord_2_spdb \s-1FNAME\s0 \s-1COORD\s0 \s-1SCOR_SET\s0 \s-1SEQ\s0" 4
.IX Item "coord_2_spdb FNAME COORD SCOR_SET SEQ"
.PD
Identical to \fBcoord_2_pdb\fR (above), this function additionally
writes a temperature value in the generated \s-1PDB\s0 file, corresponding
to the score given in \s-1SCOR_SET\s0 (a \fBScor_set\fR pointer) for each
residue in \s-1COORD\s0.
.Sp
See the entry for the function \fBscor_set_simpl\fR (below) for
an example.
.IP "coord_2_pnlty \s-1COORD\s0 \s-1VALUE\s0" 4
.IX Item "coord_2_pnlty COORD VALUE"
\&\s-1COORD\s0 is a \f(CW\*(C`Coord\*(C'\fR type object. \s-1VALUE\s0 is a floating point
number.
Returns a FloatPtr (floating point array) which will be used
for extra gap penalty weights during alignments.
At each site in \s-1COORD\s0, see if it is in secondary structure. If
so, it gets an extra weight, given by \s-1VALUE\s0. The exact method
is more complicated.
.Sp
If we have a structure which looks like
.Sp
.Vb 2
\&    1 2 3 4 5 6 7
\&    - E E E H - -
.Ve
.Sp
The we say that \*(L"E\*(R" and \*(L"H\*(R" refer to extended (beta strand)
and helix, so residues 2\ \-\ 5 look as if they are in
interesting secondary structure. In fact, the situation is
more interesting. Residue 1 is adjoining a piece of secondary
structure, and residue 2 is on the edge of one. Only residues
3\ \-\ 4 are really definitely inside secondary structure and
residue 7 is definitely outside one.
If \s-1VALUE\s0 is set to 10, then the coefficients will be
.Sp
.Vb 8
\& residue  coefficient
\& 1        3.25
\& 2        7.75
\& 3       10
\& 4       10
\& 5        7.75
\& 6        3.25
\& 7        1
.Ve
.IP "dmat_b_cliques \s-1MODEL\s0 \s-1REFERENCE\s0 \s-1BOUND\s0 \s-1SIZE\s0" 4
.IX Item "dmat_b_cliques MODEL REFERENCE BOUND SIZE"
Returns a list of intervals on \s-1MODEL\s0's coordinates
corresponding to 'flat' areas of the difference of distance
matrices between \s-1MODEL\s0 and \s-1REFERENCE\s0 (which could be the native
fold of the sequence modelled by \s-1MODEL\s0).
.Sp
The list should be interpreted as ranges in the residues
of \s-1MODEL\s0 :
.Sp
.Vb 1
\&   start1, end1, start2, end2, ...
.Ve
.Sp
These define contiguous stretches of \s-1MODEL\s0's structure whose
distance contacts differ by less than \s-1BOUND\s0 angstroms from
those in \s-1REFERENCE\s0. Each interval is at least of size \s-1SIZE\s0.
.Sp
There are some default parameters :
.Sp
.Vb 2
\&      my @good_regions_of_model =
\&          dmat_b_cliques $model, $native;
.Ve
.Sp
Returns the flat regions longer than 9 residues where
\&\s-1DME\s0 is less than 1 angstrom.
.IP "dme_thresh \s-1FRACTION\s0 \s-1COORD1\s0 \s-1COORD2\s0 \s-1THRESHOLD\s0" 4
.IX Item "dme_thresh FRACTION COORD1 COORD2 THRESHOLD"
Compare the distance matrices from \s-1COORD1\s0 and \s-1COORD2\s0. Calculate
the fraction of the distance matrix left after setting a
threshold of \s-1THRESHOLD\s0. Put this fraction into \s-1FRACTION\s0.
.Sp
Returns the useful answer in \s-1FRACTION\s0, but returns undef on
error.
.Sp
\&\s-1DME\s0 stands for \*(L"distance matrix error\*(R", a name coined in Havel,\ \s-1TF\s0,
Biopolymers, 29, 1565\-1585 (1990), but it is really the root mean
square difference of distance matrices. To compare structures we
calculate the \s-1DME\s0 based on alpha carbon coordinates. We then go
back to the distance original distance matrices and find the most
different matrix elements and enter a loop:
.Sp
.Vb 3
\&  while (DME > threshold)
\&      remove most different element from calculation
\&  return the fraction of the distance matrix remaining
.Ve
.Sp
If the two sets of coordinates were very similar, then we did not
have to remove any matrix elements, so we return a value near
1.0. If the coordinates were very different, we had to throw away
most matrix elements, so we return a number closer to 0.0.
.Sp
A good value for \s-1THRESHOLD\s0 is about 3.5 or 4.0 Angstrom. This
measure of similarity is bounded by 0 and 1.0 and is not too
sensitive to protein size.
.IP "dme_nice \s-1MODEL\s0 \s-1REF\s0 \s-1BOUND\s0 \s-1SIZE\s0 \s-1CORE\s0 \s-1CORE_BORDER\s0" 4
.IX Item "dme_nice MODEL REF BOUND SIZE CORE CORE_BORDER"
Returns a list of intervals defining bounded regions of
the difference of distance matrices between \s-1MODEL\s0 and \s-1REF\s0.
Whereas in dme_b_cliques, the intervals define bounded regions,
the 'nice' regions defined by this function allow for some
deviations at the boundary of the flat regions of a \s-1DME\s0 plot.
\&\s-1SIZE\s0 refers to the structural fragment size, and \s-1CORE\s0 refers
to the minimum size of a bounded region expressed as the number
of overlapping fragments.
\&\s-1CORE_BORDER\s0 is the size of the boundary region where deviation
is allowed. Essentially this means that pairs of intervals that
would be returned by dmat_b_cliques will be merged if they are
separated by fewer than \s-1CORE_BORDER\s0 residues.
.IP "dpt_get_n \s-1DPT_LIST\s0" 4
.IX Item "dpt_get_n DPT_LIST"
Return the number of items in \s-1DPT_LIST\s0.
Zero means there are no items.
There is no scope for error returns from this function since
.RS 4
.IP "* zero is a legitimate value" 4
.IX Item "zero is a legitimate value"
.PD 0
.IP "* formatting errors should be detected at the file reading stage" 4
.IX Item "formatting errors should be detected at the file reading stage"
.IP "* the perl interpreter should ensure that only items of the correct type are passed in." 4
.IX Item "the perl interpreter should ensure that only items of the correct type are passed in."
.RE
.RS 4
.RE
.IP "dpt_get_val \s-1DPT_LIST\s0 N" 4
.IX Item "dpt_get_val DPT_LIST N"
.PD
Return the value (floating point) associated with the \fIN\fRth
value in the list. Zero refers to the first value on the list.
.Sp
\&\fIImportant\fR: Elements of the \s-1DPT_LIST\s0 are re-ordered (sorted)
after they read. The 4th element in the original list may not be
the 4th element internally.
.IP "dpt_set_val \s-1DPT_LIST\s0 N \s-1VAL\s0" 4
.IX Item "dpt_set_val DPT_LIST N VAL"
Set the \fIN\fRth value in \fI\s-1DPT_LIST\s0\fR to the floating point number,
\&\fI\s-1VAL\s0\fR. The numbering of items starts from zero.
.Sp
Returns 1 on success and undef on failure. This routine can fail
if the value \fIN\fR\ >=\ numb_items_on_list.
.Sp
\&\fIImportant\fR: See the note on list re-ordering above.
.IP "dpt_read \s-1FILE\s0" 4
.IX Item "dpt_read FILE"
Read the contents of \s-1FILE\s0 as a list of dipeptide information.
The format is
.Sp
.Vb 5
\& # comments are allowed in this file
\& ab cd kdist val        # inline comments are also ok
\&                        # as are blank lines.
\& ef gh kdist            # If val is not set, it defaults to 1.0
\&  ....
.Ve
.Sp
Where
.RS 4
.IP "ab" 4
.IX Item "ab"
\&\fIab\fR, \fIcd\fR are the members of a pair of dipeptides. They must
be lower case, valid amino acids. The lower case restriction
should be removed.
.IP "kdist" 4
.IX Item "kdist"
is a positive integer telling us the separation of residues in
the dipeptide. A value of kdist=1 means adjacent amino acids.
.IP "val" 4
.IX Item "val"
is the value associated with this pair for use in a scoring
matrix. It is not compulsory. If it is not present, a default
value of 1.0 will be used.
.RE
.RS 4
.RE
.IP "dpt_string \s-1DPT_LIST\s0" 4
.IX Item "dpt_string DPT_LIST"
Return the information from \s-1DPT_LIST\s0 as a string as in
.Sp
.Vb 1
\& print "Data from file was\en", dpt_string (dpt_list), "\en";
.Ve
.IP "dssp \s-1COORD\s0" 4
.IX Item "dssp COORD"
Run the \s-1DSSP\s0 program on the coordinates in \s-1COORD\s0.  Store the
answer in \s-1COORD\s0.
.IP "make_model \s-1PAIR_SET\s0 \s-1SEQ\s0 \s-1COORD\s0" 4
.IX Item "make_model PAIR_SET SEQ COORD"
Given an alignment in \s-1PAIR_SET\s0 (a \fBPair_set\fR pointer) which
comes from sequence \s-1SEQ\s0 aligned to coordinates \s-1COORD\s0, return a
\&\fBCoord\fR pointer with a model of the sequence on the coordinates.
.IP "model_pdb_num \s-1COORD\s0 \s-1MODELNUM\s0" 4
.IX Item "model_pdb_num COORD MODELNUM"
Given a \fB\s-1COORD\s0 \s-1OBJECT\s0\fR and a residue position, returns the
original \s-1PDB\s0 number stored for that residue.
.IP "model_res_num \s-1COORD\s0 \s-1RESIDUENUM\s0" 4
.IX Item "model_res_num COORD RESIDUENUM"
Given a \fB\s-1COORD\s0 \s-1OBJECT\s0\fR and a residue number (according to \s-1PDB\s0
sequence numbering), returns the index for that residue in the
coord object, or undefined if there is no coordinates for that
sequence number.
.IP "num_seq \s-1SEQ_ARRAY\s0" 4
.IX Item "num_seq SEQ_ARRAY"
Returns the number of sequences in a sequence array.
.IP "pair_set_coverage \s-1PAIR_SET\s0 \s-1SIZE1\s0 \s-1SIZE2\s0" 4
.IX Item "pair_set_coverage PAIR_SET SIZE1 SIZE2"
Given an alignment, we often want to know what part of the
sequence or structure is accounted for. For example
.Sp
.Vb 2
\& A B C - - D E - F G H
\&     Q R S T U V W - Y Z
.Ve
.Sp
In the first string, you could imagine the residues we
know about are like
.Sp
.Vb 1
\& 0 0 1 1 1 1 0 1
.Ve
.Sp
while in the second string, the pattern is like
.Sp
.Vb 1
\& 1 0 0 1 1 0 1 1
.Ve
.Sp
Call this function with a pair set and the size of the first and
second objects (sequences or sequence/structure pair).
pair_set_coverage returns two lists. One for each member of the
alignment respectively.
.Sp
This returns a pair of strings. In each string, a '0' char means
the site is not covered by the alignment, but a '1' means it
is.  On failure, returns undef. A typical use would be
.Sp
.Vb 4
\& my ($s1, $s2) =
\&     pair_set_coverage ($pair_set, seq_size ($seq), coord_size ($coord);
\& print "Pattern of sequence coverage looks like\en$s1\en";
\& print "Pattern of struct coverage looks like \en$s2\en";
.Ve
.Sp
and the output strings might look like
.Sp
.Vb 1
\&  00100111
.Ve
.Sp
Which would mean that the 3rd, 6th and 7th positions were
properly aligned.  Note also that this leaves room for some
tricks.
Strings can be binary &'d to look for overlap and '1's can be
quickly counted using perl matching operators.
.ie n .IP "pair_set_extend \s-1PAIR_SET\s0 $EXT_LONG" 4
.el .IP "pair_set_extend \s-1PAIR_SET\s0 \f(CW$EXT_LONG\fR" 4
.IX Item "pair_set_extend PAIR_SET $EXT_LONG"
.PD 0
.ie n .IP "pair_set_extend \s-1PAIR_SET\s0 $EXT_SHORT" 4
.el .IP "pair_set_extend \s-1PAIR_SET\s0 \f(CW$EXT_SHORT\fR" 4
.IX Item "pair_set_extend PAIR_SET $EXT_SHORT"
.PD
If you have done a Smith and Waterman style alignment, you
may not have all residues aligned. Consider
.Sp
.Vb 2
\&   A  B  C  D  Q  R  S  E
\&         X  Y  Q  R  S  X  Y
.Ve
.Sp
The alignment from a highest scoring segment is
.Sp
.Vb 2
\&               Q  R  S
\&               Q  R  S
.Ve
.Sp
and this is what we will likely get if we don't ask
otherwise.
but we could reasonably do a short extension to include
residues which go out to the ends of the shorter sequence.
.Sp
.Vb 2
\&         C  D  Q  R  S  E
\&         X  Y  Q  R  S  X
.Ve
.Sp
One may also want a longer extension, which would look like
.Sp
.Vb 2
\&   A  B  C  D  Q  R  S  E  -
\&   -  -  X  Y  Q  R  S  X  Y
.Ve
.Sp
Given these definitions of extension, (long and short), you
may want either result.
.Sp
The symbols, \f(CW$EXT_LONG\fR and \f(CW$EXT_SHORT\fR are constants. You
should choose one of them.
.IP "pair_set_gap   \s-1PAIR_SET\s0 \s-1SCALE_OPEN\s0 \s-1SCALE_WIDEN\s0" 4
.IX Item "pair_set_gap   PAIR_SET SCALE_OPEN SCALE_WIDEN"
Like \f(CW\*(C`coord_geo_gap\*(C'\fR, this is for calculating extra gap
penalties after doing an alignment. This returns a gap penalty
for the sequence, not the structure.  It returns two values like
.Sp
.Vb 3
\&  my ($open_penalty, $widen_penalty);
\&  ($open_penalty, $widen_penalty)
\&     = pair_set_gap($pair_set, $o_scl, $w_scl);
.Ve
.Sp
For each gap, the penalty is calculated as
.Sp
.Vb 1
\&  penalty = open_scale + (n - 1) * widen_scale
.Ve
.Sp
where \f(CW\*(C`n\*(C'\fR is the length of the gap.  Because these things are
linear, you can get the number of gaps in a whole alignment from
\&\f(CW\*(C`n_gap\ =\ $open_penalty\ /\ $open_scale\*(C'\fR.
.IP "pair_set_score \s-1PAIR_SET\s0" 4
.IX Item "pair_set_score PAIR_SET"
This returns two floating point numbers. The first is the score
from an alignment, including gaps. The second is the score, not
including gaps. The intentions are to
.RS 4
.IP "*" 4
Let one look at the pure sequence-structure score and
.IP "*" 4
Let one use a more sophisticated gap scoring scheme than the one
used in the alignment calculation.
.RE
.RS 4
.Sp
For example, we have have something like
.Sp
.Vb 4
\& my $pair_set = score_mat_sum_sec (.....);
\& my ($score, $simple_score) = pair_set_score ($pair_set);
\& print "Score with gaps is ", $score,
\&       "without gaps is ", $simple_score, "\en";
.Ve
.Sp
For compatibility with old scripts, it is still \s-1OK\s0 to say
.Sp
.Vb 1
\& my $score = pair_set_score ($pair_set)
.Ve
.RE
.IP "pair_set_string \s-1PAIR_SET\s0 \s-1SEQ1\s0 \s-1SEQ2\s0" 4
.IX Item "pair_set_string PAIR_SET SEQ1 SEQ2"
Return a string for printing. \s-1PAIR_SET\s0 is an alignment
corresponding to \s-1SEQ1\s0 and \s-1SEQ2\s0. If this came from a sequence
to structure alignment, we still want the sequence
corresponding to \s-1SEQ2\s0. This is easy to get from
.Sp
.Vb 1
\&   coord_get_seq (C)
.Ve
.Sp
but this routine should be renamed \f(CW\*(C`seq_from_coord()\*(C'\fR.
.IP "pair_set_pretty_string \s-1PAIR_SET\s0 \s-1SEQ1\s0 \s-1SEQ2\s0 \s-1SEC_S_DATA\s0 \s-1COORD2\s0" 4
.IX Item "pair_set_pretty_string PAIR_SET SEQ1 SEQ2 SEC_S_DATA COORD2"
.PD 0
.IP "pair_set_pretty_string \s-1PAIR_SET\s0 \s-1SEQ1\s0 \s-1SEQ2\s0" 4
.IX Item "pair_set_pretty_string PAIR_SET SEQ1 SEQ2"
.PD
Return a string with a pretty alignment.
.Sp
If you have secondary structure data (\s-1SEC_S\s0) which has probably
come from a predictor and if you provide the coordinates
(\s-1COORD2\s0), then the output will include this secondary structure
information.
.IP "param_fx_read \s-1FNAME\s0" 4
.IX Item "param_fx_read FNAME"
Read parameters for Thomas' Bayesian scoring / alignment
functions.
Returns an FXParam object on success, or undefined on failure.
.IP "param_rs_read \s-1FNAME\s0" 4
.IX Item "param_rs_read FNAME"
Read parameters for the \fItanh()\fR based score function with all
atoms. This is for rescoring, not alignment.
Returns an RSParam object on success, or undefined on failure.
.IP "pdb_read \s-1FNAME\s0 \s-1ACQ_CODE\s0 \s-1CHAIN\s0" 4
.IX Item "pdb_read FNAME ACQ_CODE CHAIN"
Read the pdb file, \s-1FNAME\s0, and return a Coord object. Note that
this will not include secondary structure information.  \s-1ACQ_CODE\s0
is the acquisition code. It can be blank, in which case, the
program will try to guess the code from the filename. \s-1CHAIN\s0 can
also be blank, or a single letter, chain specifier.
.Sp
This function is for rewriting lots of files, for example, when
we rebuild a library. This means it tolerates errors rather than
stopping. Furthermore, it contains a list of residue name
substitutions. For example, it will change
.Sp
.Vb 5
\& original new_name   comment
\& ---------------------------
\& UNK      ALA        Unknown residues become alanine
\& MSE      MET        Selenomethionine becomes methionine
\& CSE      CYS        Selenocysteine becomes cystein
.Ve
.Sp
There are currently more than 20 of these conversions. They are a
one way affair. After reading the coordinates, the original name
is thrown away.
.IP "prob_vec_info \s-1PROB_VEC\s0" 4
.IX Item "prob_vec_info PROB_VEC"
\&\fB\s-1PROB_VEC\s0\fR is a matrix of class probabilities. This returns a
string containing some minimal information. Functions like
\&\*(L"seq_2_prob_vec\*(R" return a probability vector.
.IP "scor_set_simpl \s-1PAIR_SET\s0 \s-1SCORE_MAT\s0" 4
.IX Item "scor_set_simpl PAIR_SET SCORE_MAT"
Returns a \fBScor_set\fR object, corresponding to the local
score for each aligned pair of residues in \s-1PAIR_SET\s0, based on
the scores in \s-1SCORE_MAT\s0. These local scores, when summed, yield
the 'simple score' returned by \fBpair_set_score\fR.
.Sp
The obvious use of this function is to generate an annotated
\&\s-1PDB\s0 file :
.Sp
.Vb 3
\&  coord_2_spdb ("1mypC.pdb", make_model($pair_set, $seq, $template)
\&                           , scor_set_simpl($pair_set,
\&                                            $tot_score_mat));
.Ve
.Sp
Where the temperature entry of the each residue in the model will
be set to the local score given in the score matrix.
.ie n .IP "scor_set_fromvec @SCORES" 4
.el .IP "scor_set_fromvec \f(CW@SCORES\fR" 4
.IX Item "scor_set_fromvec @SCORES"
Returns a \fBScor_set\fR object containing the vector of scores given
in \f(CW@SCORES\fR.
.ie n .IP "scor_set_to_vec $scor_set" 4
.el .IP "scor_set_to_vec \f(CW$scor_set\fR" 4
.IX Item "scor_set_to_vec $scor_set"
Returns a vector of doubles corresponding to the scores contained
in the \fBScor_set\fR object.  This is useful when you want to actually
print out the scores for an alignment :
.Sp
.Vb 2
\&    # float_to_character maps a signed float to a
\&    # scale of alphanumerics
.Ve
.Sp
.Vb 1
\&    sub d2c( $ ) { return float_to_character ( $_ ) };
.Ve
.Sp
.Vb 5
\&    my $i=0;
\&    my $cs = pair_set_coverage( $pairset, $seq_len, $coord_len );
\&    my $scor = scor_set_to_vec( $scor_set); # from $pair_set
\&    $cs=~ s/0/./g;
\&    $cs=~ s/1/d2c($$scor[$i++]);/ge;
.Ve
.Sp
.Vb 2
\&    # $cs is now a coverage string where every aligned position is
\&    # scored according to float_to_character.
.Ve
.IP "scor_set_scale \s-1SCOR_SET\s0 \s-1SCALE\s0" 4
.IX Item "scor_set_scale SCOR_SET SCALE"
Returns true if it managed to divide each entry in the \fBScor_set\fR by
the scalar in \s-1SCALE\s0.
.IP "score_fx \s-1MATRIX\s0 \s-1SEQ\s0 \s-1COORD\s0 \s-1PARAM\s0" 4
.IX Item "score_fx MATRIX SEQ COORD PARAM"
Fill out a score matrix for a sequence structure pair, based on
Herr Doktor Huber's Bayesian-based score function. This score
function works for sequence to structure alignments.
.Sp
\&\s-1MATRIX\s0 is a new created score matrix, probably returned from
\&\fBscore_mat_new\fR. \s-1SEQ\s0 is a sequence object (SeqPtr) \s-1COORD\s0 is a
coordinate object (CoordPtr). \s-1PARAM\s0 are parameters from
\&\f(CW\*(C`param_fx_read\*(C'\fR. They have type FXParam and this type checking
is enforced by the interpreter.
.IP "score_fx_prof \s-1MATRIX\s0 \s-1SP\s0 \s-1COORD\s0 \s-1PARAM\s0" 4
.IX Item "score_fx_prof MATRIX SP COORD PARAM"
This is the same as score_fx, but the second argument, \f(CW\*(C`SP\*(C'\fR, is
a sequence profile, rather than a sequence.
.IP "score_mat_add (\s-1MAT1\s0, \s-1MAT2\s0, \s-1SCALE\s0, \s-1SHIFT\s0)" 4
.IX Item "score_mat_add (MAT1, MAT2, SCALE, SHIFT)"
Return a new score matrix where each element is given by
.Sp
.Vb 1
\& NEW_MAT = MAT1 + ( SCALE * MAT2 + SHIFT)
.Ve
.Sp
If only three arguments are given, \s-1SHIFT\s0 is set to zero.
.IP "score_mat_info \s-1MAT\s0" 4
.IX Item "score_mat_info MAT"
Given a Score_mat object in \s-1MAT\s0, return a list of the form
  (\s-1MIN\s0, \s-1MAX\s0, \s-1AV\s0, \s-1STD_DEV\s0)
Ignore the first and last row and column, since they are used for
treatment of end gaps.
.Sp
Note, the calling procedure for this function changed in May\ 2006, so old scripts may break;
.IP "score_mat_new N_ROWS N_COLS" 4
.IX Item "score_mat_new N_ROWS N_COLS"
Create a new score matrix and return a Score_mat object.
In a sequence to structure alignment, N_ROWS is the size of
the sequence, N_COLS is the size of the structure. So, if
\&\f(CW$seq\fR is a sequence and \f(CW$coord\fR is a structure, we might
have
.Sp
.Vb 1
\&  $scr_mat = score_mat_new (seq_size ($seq), coord_size ($coord));
.Ve
.Sp
You \fBare\fR entitled to assume that the new matrix is properly
zeroed. Code should not bother to zero it again.
.IP "score_mat_scale \s-1MAT\s0, \s-1SCALE\s0" 4
.IX Item "score_mat_scale MAT, SCALE"
Multiply all elements in \s-1MAT\s0 by \s-1SCALE\s0. This returns a new matrix.
.IP "score_mat_shift (\s-1MAT1\s0, \s-1SHIFT\s0)" 4
.IX Item "score_mat_shift (MAT1, SHIFT)"
Return a new score matrix where each element is given by
.Sp
.Vb 1
\& NEW_MAT = MAT1 + SHIFT
.Ve
.Sp
The first and last row and column are not shifted. This is one
way to implement end gaps.  This function returns a new matrix.
.IP "score_pvec \s-1MATRIX\s0, \s-1PVEC1\s0, \s-1PVEC2\s0" 4
.IX Item "score_pvec MATRIX, PVEC1, PVEC2"
Fill out the score matrix, \fB\s-1MATRIX\s0\fR based on comparing the
class membership probability vectors \fB\s-1PVEC1\s0\fR and \fB\s-1PVEC2\s0\fR.
These probability vectors check the length of the original
fragments and will return \fBundef\fR if they do not match.
.IP "score_mat_read \s-1FNAME\s0" 4
.IX Item "score_mat_read FNAME"
Go to \fI\s-1FNAME\s0\fR and read the score matrix that was probably
written by score_mat_write. Return a new score matrix or undef
on failure like
.Sp
.Vb 3
\& my $scr_mat = score_mat_read ($fname);
\& if (! $scr_mat) {
\&     print STDERR "Reading score matrix from $fname failed.\en"; }
.Ve
.IP "score_mat_string \s-1SCORE_MAT\s0 \s-1SEQ1\s0 \s-1SEQ2\s0" 4
.IX Item "score_mat_string SCORE_MAT SEQ1 SEQ2"
This is mainly for debugging. After calling a score function,
this will return a string containing the score matrix with the
sequence at the top and left hand side. If you did a sequence
to structure alignment, you should still call it with the
sequences.
.IP "score_mat_sum_full \s-1RMAT\s0, \s-1SCORE_MAT\s0, \s-1PGAP_OPEN\s0, \s-1PGAP_WIDEN\s0, \s-1QGAP_OPEN\s0, \s-1QGAP_WIDEN\s0,P_MULT, Q_MULT, \s-1ALIGN_TYPE\s0" 4
.IX Item "score_mat_sum_full RMAT, SCORE_MAT, PGAP_OPEN, PGAP_WIDEN, QGAP_OPEN, QGAP_WIDEN,P_MULT, Q_MULT, ALIGN_TYPE"
.PD 0
.IP "score_mat_sum_full \s-1RMAT\s0, \s-1SCORE_MAT\s0, \s-1PGAP_OPEN\s0, \s-1PGAP_WIDEN\s0, \s-1QGAP_OPEN\s0, \s-1QGAP_WIDEN\s0,P_MULT, Q_MULT, \s-1ALIGN_TYPE\s0, \s-1BIAS_SET\s0" 4
.IX Item "score_mat_sum_full RMAT, SCORE_MAT, PGAP_OPEN, PGAP_WIDEN, QGAP_OPEN, QGAP_WIDEN,P_MULT, Q_MULT, ALIGN_TYPE, BIAS_SET"
.PD
This does the summation of a score matrix. Returns non-zero on
success and zero on failure.
Note, there is an optional last argument.
The parameters are
.RS 4
.IP "\s-1RMAT\s0" 8
.IX Item "RMAT"
This is used for returning the summed matrix. The function
does not overwrite \s-1SCORE_MAT\s0. Instead it returns a new
matrix. This can generally be ignored.
.IP "\s-1SCORE_MAT\s0" 8
.IX Item "SCORE_MAT"
This is the score matrix which came from a call to something
like \fBscore_smat\fR.
.IP "\s-1PGAP_OPEN\s0" 8
.IX Item "PGAP_OPEN"
Penalty for opening gaps in the first of the pair of sequences
or structures or whatever.
.IP "\s-1PGAP_WIDEN\s0" 8
.IX Item "PGAP_WIDEN"
Penalty for extending the PGAPs.
.IP "\s-1QGAP_OPEN\s0" 8
.IX Item "QGAP_OPEN"
Penalty for opening gaps in the second of the pair.
.IP "\s-1QGAP_WIDEN\s0" 8
.IX Item "QGAP_WIDEN"
Penalty for extending the QGAPs
.IP "P_MULT" 8
.IX Item "P_MULT"
This is an object of \f(CW\*(C`FloatPtr\*(C'\fR type with site specific
coefficients for gap penalties and will be applied to the
P_GAP. Typically, this will be for extra penalties for
secondary structure gaps.
.IP "Q_MULT" 8
.IX Item "Q_MULT"
As for P_MULT, but for the q_gaps.
.IP "\s-1ALIGN_TYPE\s0" 8
.IX Item "ALIGN_TYPE"
Either \*(L"$N_AND_W\*(R" or \*(L"$S_AND_W\*(R" for Needleman and Wunsch or
Smith and Waterman respectively.
.IP "\s-1BIAS_SET\s0" 8
.IX Item "BIAS_SET"
This is a pair_set which may have come from a previous
alignment. It really is an object of Pair_setPtr type.  It is
optional. If present, the alignment will be coerced to follow
this alignment.  The use is that one can do an Smith and Waterman
alignment and get the best scoring segment. One can then set the
\&\s-1ALIGN_TYPE\s0 switch to \f(CW$N_AND_W\fR and do a globally optimal
alignment, but passing through the optimal segment.
.RE
.RS 4
.RE
.IP "score_mat_write \s-1SCORE_MAT\s0 \s-1FNAME\s0" 4
.IX Item "score_mat_write SCORE_MAT FNAME"
Write the score matrix \s-1SCORE_MAT\s0 to the file name given by
\&\s-1FNAME\s0. Return undef on failure.
.IP "score_rs \s-1COORD\s0 \s-1PARAMS\s0" 4
.IX Item "score_rs COORD PARAMS"
This will apply the \fItanh()\fR based score function which is
primarily for rescoring. It is \fB\s-1NOT\s0\fR neighbour-non-specific
or unusual in any other way.
.Sp
\&\s-1COORD\s0 is a Coord object.
\&\s-1PARAMS\s0 is a set of parameters, formally of type RSParams and
probably resulting from a call to param_rs_read.
.Sp
Returns a floating point number.
.IP "score_smat \s-1SCORE_MAT\s0, \s-1SEQ1\s0, \s-1SEQ2\s0, \s-1SUB_MAT\s0" 4
.IX Item "score_smat SCORE_MAT, SEQ1, SEQ2, SUB_MAT"
Fill out a score matrix based on sequence comparison of two
sequences.
\&\s-1SCORE_MAT\s0 is a score matrix which may have come from
new_matrix.
\&\s-1SEQ1\s0 and \s-1SEQ2\s0 are the sequences.
\&\s-1SUB_MAT\s0 is a substitution matrix.
.IP "score_sprof \s-1SCORE_MAT\s0, \s-1PROF\s0, \s-1SEQ\s0, \s-1SUB_MAT\s0" 4
.IX Item "score_sprof SCORE_MAT, PROF, SEQ, SUB_MAT"
This is very similar to \fBscore_smat\fR.
\&\s-1SCORE_MAT\s0 is a score matrix, probably from \fBnew_matrix\fR.
\&\s-1PROF\s0 is a sequence profile, maybe from \fBblst_chk_read\fR.
\&\s-1SEQ\s0 is a sequence and \s-1SUB_MAT\s0 is a substition matrix.
This fills out a score matrix using the substition matrix it has
been given and fractional sequences from the sequence profile.
.IP "score_sec_s \s-1SCORE_MAT\s0, \s-1SEC_S_DATA\s0, \s-1COORD\s0" 4
.IX Item "score_sec_s SCORE_MAT, SEC_S_DATA, COORD"
Given a \s-1SCORE_MAT\s0 which probably came from \f(CW\*(C`score_mat_new\*(C'\fR, and
some secondary structure data in \s-1SEC_S_DATA\s0, probably from
\&\f(CW\*(C`sec_s_data_read\*(C'\fR and a set of coordinates in \s-1COORD\s0, do a
scoring.
.Sp
We compare each site against the predicted secondary
structure. If the psi angle difference is more than 90 degrees,
we set it to 90. We then return cos (difference). Note, this is
different behaviour to earlier versions. If an angle is very
different (diff > 90), it it not penalised. If the angle is less
than 90, a value will be returned between 0 and 1.0
.IP "sec_s_data_read \s-1FNAME\s0" 4
.IX Item "sec_s_data_read FNAME"
Read secondary structure data from \s-1FNAME\s0.
This may be in PHD/Rost format or our
\&\*(L"item_manual_secondary_structure_file\*(R" in \*(L"manual input format\*(R"
format defined below.
Return a pointer to an object of Sec_s_data type.
.IP "sec_s_data_string \s-1SEC_S\s0" 4
.IX Item "sec_s_data_string SEC_S"
\&\s-1SEC_S\s0 is a pointer to a Sec_s_data object.
Return a string with the bare secondary structure
information. For example:
.Sp
.Vb 3
\&    $x = sec_s_data_read ("sec_data_file")
\&           || die "Fail on $tmp_data: $!";
\&    print sec_s_data_string($x);
.Ve
.IP "seq_2_prob_vec \s-1SEQ\s0, \s-1AA_CLSSFCN\s0 Given a sequence, \fB\s-1SEQ\s0\fR and an amino acid classification, \fB\s-1AA_CLSSFCN\s0\fR return an object of \fB\s-1PROB_VEC\s0\fR type. This is most interesting for feeding to a score function like \fBscore_pvec\fR." 4
.IX Item "seq_2_prob_vec SEQ, AA_CLSSFCN Given a sequence, SEQ and an amino acid classification, AA_CLSSFCN return an object of PROB_VEC type. This is most interesting for feeding to a score function like score_pvec."
.PD 0
.IP "seq_read \s-1FNAME\s0" 4
.IX Item "seq_read FNAME"
.PD
Read a sequence from file \s-1FNAME\s0.
Returns a SeqPtr object.
.IP "seq_read_many \s-1FNAME\s0" 4
.IX Item "seq_read_many FNAME"
Reads a number of sequences from file \s-1FNAME\s0.
Returns a SeqArrayPtr object (array of sequences).
.IP "seq_from_string \s-1STRING\s0" 4
.IX Item "seq_from_string STRING"
Returns a sequence object \f(CW\*(C`SeqPtr\*(C'\fR from a string. This lets
one build a sequence in the interpreter like
.Sp
.Vb 1
\& $seq = seq_from_string ('avlc');
.Ve
.Sp
Would store a sequence (Ala, Val, Leu, Cys) in the \f(CW$seq\fR
variable.  The string can have a \s-1FASTA\s0 style comment at the
start. The string can span multiple lines.
.IP "seq_get_1 \s-1SEQ_ARRAY\s0 N" 4
.IX Item "seq_get_1 SEQ_ARRAY N"
Return the N'th string from a sequence array, \s-1SEQ_ARRAY\s0.
Returns a SeqPtr object.
.IP "seq_num \s-1SEQ_ARRAY\s0" 4
.IX Item "seq_num SEQ_ARRAY"
Returns the number of sequences stored in the sequence array,
\&\s-1SEQ_ARRAY\s0.
.IP "seq_print \s-1SEQ\s0" 4
.IX Item "seq_print SEQ"
Return a sequence to the interpreter as a string. It is not
pretty and will be fixed.
.RS 4
.IP "*" 8
The sequence will be beautified so it comes out in blocks of
ten residues, probably with numbering.
.RE
.RS 4
.RE
.IP "seq_print_many \s-1SEQ_ARRAY\s0" 4
.IX Item "seq_print_many SEQ_ARRAY"
Returns a string containing all the sequences in \s-1SEQ_ARRAY\s0.
.IP "seq_size \s-1SEQ\s0" 4
.IX Item "seq_size SEQ"
Return the number of residues in a sequence, \s-1SEQ\s0.
.Sp
This is the number of residues in a sequence. There are no
complications or frills like null terminators.
.IP "seqprof_get_seq \s-1SEQPROF\s0" 4
.IX Item "seqprof_get_seq SEQPROF"
This is analogous to coord_get_seq. It takes a sequence profile
and returns a \fBSeq\fR sequence.
.IP "seqprof_str \s-1SEQPROF\s0" 4
.IX Item "seqprof_str SEQPROF"
Take the sequence profile in the \s-1SEQPROF\s0 object and return a
printable string. For example
.Sp
.Vb 3
\&    if ( ! ($profile = blst_chk_read ( $fname))) {
\&        return undef; }
\&    print seqprof_str ($profile);
.Ve
.IP "struct_2_prob_vec \s-1COORD\s0 \s-1CLSSFCN\s0 Computes the memberships matrix (probability vector) for a structure \s-1COORD\s0 given a \s-1CLSSFCN\s0" 4
.IX Item "struct_2_prob_vec COORD CLSSFCN Computes the memberships matrix (probability vector) for a structure COORD given a CLSSFCN"
.PD 0
.IP "sub_mat_get_by_i \s-1SUB_MAT\s0, \fIM\fR, \fIN\fR" 4
.IX Item "sub_mat_get_by_i SUB_MAT, M, N"
.PD
Return the substition matrix element indexed by \fBM\fR and \fBN\fR
.IP "sub_mat_get_by_c \s-1SUB_MAT\s0, \fIA\fR, \fIB\fR" 4
.IX Item "sub_mat_get_by_c SUB_MAT, A, B"
Return the substitution matrix element for the amino acids \fIA\fR
and \fIB\fR. So \f(CW\*(C`$a\ =\ sub_mat_get_by_c\ ($sub_mat,\ 'c',\ 'd');\*(C'\fR
would return the current value for cys/asp. The amino acid names
are single letter codes and may be upper or lower case.
.IP "sub_mat_set_by_c \s-1SUB_MAT\s0, \fIA\fR, \fIB\fR, \fIval\fR" 4
.IX Item "sub_mat_set_by_c SUB_MAT, A, B, val"
Set the substitution matrix element for \fIA\fR and \fIB\fR to
\&\fIval\fR.
.IP "sub_mat_set_by_i \s-1SUB_MAT\s0, \fIM\fR, \fIN\fR, \fIval\fR" 4
.IX Item "sub_mat_set_by_i SUB_MAT, M, N, val"
Set the value indexed by \fIM\fR,\fIN\fR in the substition matrix to \fIval\fR.
.IP "sub_mat_string \s-1SUB_MAT\s0" 4
.IX Item "sub_mat_string SUB_MAT"
Return a string containing the substitution\ /\ score matrix
held in \s-1SUB_MAT\s0.
.IP "sub_mat_read (\s-1FILENAME\s0)" 4
.IX Item "sub_mat_read (FILENAME)"
Go to \s-1FILENAME\s0. Read up the substitution / score matrix and
return it.
.IP "sub_mat_shift \s-1SUBST_MATRIX\s0, \s-1BOTTOM\s0" 4
.IX Item "sub_mat_shift SUBST_MATRIX, BOTTOM"
Given a substitution matrix (an object of type Sub_mat), shift
the whole matrix so the smallest (most negative value) is of
size \s-1BOTTOM\s0.  This does not return anything. It acts on the
\&\s-1SUBST_MATRIX\s0 argument directly.
.IP "sub_mat_scale \s-1SUBST_MATRIX\s0, \s-1BOTTOM\s0, \s-1TOP\s0" 4
.IX Item "sub_mat_scale SUBST_MATRIX, BOTTOM, TOP"
Given a substition matrix, \s-1SUBST_MATRIX\s0, scale and shift it so
the minimum and maximum values run from \s-1BOTTOM\s0 to \s-1TOP\s0.
.IP "score_mat_sum_smpl \s-1NEW_MAT\s0 \s-1SCORE_MAT\s0 \s-1PGAP_OPEN\s0 \s-1PGAP_WIDEN\s0 \s-1QGAP_OPEN\s0 \s-1QGAP_WIDEN\s0 \s-1ALIGNMENT_TYPE\s0" 4
.IX Item "score_mat_sum_smpl NEW_MAT SCORE_MAT PGAP_OPEN PGAP_WIDEN QGAP_OPEN QGAP_WIDEN ALIGNMENT_TYPE"
We have a score matrix which could be from sequence/sequence,
sequence/structure or whatever. Now, do the dynamic
programming work. Sum the score matrix and return a set of
pairs.
.Sp
The parameters are
.RS 4
.IP "\s-1NEW_MAT\s0" 4
.IX Item "NEW_MAT"
This is a fresh matrix with the traced back scores in it.
.IP "\s-1SCORE_MAT\s0" 4
.IX Item "SCORE_MAT"
This is the score matrix.
.IP "\s-1GAP_OPEN\s0" 4
.IX Item "GAP_OPEN"
.PD 0
.IP "\s-1GAP_WIDEN\s0" 4
.IX Item "GAP_WIDEN"
.IP "\s-1ALIGNMENT_TYPE\s0" 4
.IX Item "ALIGNMENT_TYPE"
.PD
There are only two values allowed, either
.Sp
.Vb 1
\&  $N_AND_W
.Ve
.Sp
or
.Sp
.Vb 1
\&  $S_AND_W
.Ve
.Sp
These stand for \*(L"Needleman and Wunsch\*(R" and \*(L"Smith and
Waterman\*(R" respectively.  Any other value will cause an error.
.RE
.RS 4
.RE
.IP "svm_rs_cdata \s-1MODEL\s0 \s-1NATIVE\s0 \s-1SCOR_SET\s0 \s-1RS_PARAM\s0 \s-1CVTYPE\s0" 4
.IX Item "svm_rs_cdata MODEL NATIVE SCOR_SET RS_PARAM CVTYPE"
*EXPERIMENTAL!*
.Sp
The function returns an array of training vectors suitable
for use in training a support vector machine (libSVM.pm) or
some other machine learning procedure. Its form is :
.Sp
.Vb 1
\&  [ [label_class, [(feature vector)], .. ]
.Ve
.Sp
The scheme for calculating the training vectory is given
in \s-1CVTYPE\s0, and the data is formed from the local sequence
to structure scores as given by \s-1SCOR_SET\s0, the \s-1TANH\s0 forcefield
based pairwise interaction terms (calculated via \s-1RS_PARAM\s0),
and the local model consistency (based on the difference of
distance matrices computed between \s-1MODEL\s0 and \s-1NATIVE\s0).
.Sp
Scheme 0 works as follows :
(see scoranlys.c:get_svmdata for details at the moment).
.IP "svm_rsfeat \s-1MODEL\s0 \s-1SCOR_SET\s0 \s-1RS_PARAMS\s0 \s-1CVTYPE\s0" 4
.IX Item "svm_rsfeat MODEL SCOR_SET RS_PARAMS CVTYPE"
This returns a set of feature vectors for each position in
\&\s-1MODEL\s0, calculated from local sequence-structure fitness and
residue-specific interaction terms according to the \s-1CVTYPE\s0
scheme (see svm_rs_cdata or scoranlys.c for details).  The
form is as follows :
.Sp
.Vb 4
\&  my @m_fvset = svm_rsfeat MODEL, SCOR_SET, PARAMS, 0
\&  @m_fvset is of form
\&    [ (undef), [feature vector], .., .., (undef)]
\&  and (scalar @m_fvset) == coord_size(MODEL)
.Ve
.Sp
undefs are given for positions in the model where a full
feature vector cannot be computed (at the ends, for instance).
.SH "BUILD AND INSTALL"
.IX Header "BUILD AND INSTALL"
Generally, nothing except the top level Makefile should be
changed.
In the top level directory, edit the Makefile, then type
.PP
.Vb 1
\&  make
.Ve
.PP
If this looks \s-1OK\s0, you might
.PP
.Vb 2
\&  cd scripts
\&  perl hello.pl
.Ve
.PP
This will check if Wurst pieces appear to be in place. If that
looks \s-1OK\s0, then edit \fIwurst/src/Wurst/Makefile.PL\fR to set the
installation destination.  Then
.PP
.Vb 1
\&  make install
.Ve
.PP
from the top level directory. Then go back to the scripts
directory and try a different file like
.PP
.Vb 2
\&  cd scripts
\&  perl hello2.pl
.Ve
.PP
This will attempt to run a test using something like \*(L"lib\*(R" as
the destination directory.
.SH "FILE FORMATS"
.IX Header "FILE FORMATS"
.IP "\s-1PHD\s0 secondary structure files" 4
.IX Item "PHD secondary structure files"
Wurst can read secondary structures from the \s-1PHD\s0 prediction
server. The format is empirically defined.  That means we try
to read anything that comes from the server.
.IP "manual secondary structure file" 4
.IX Item "manual secondary structure file"
One may type in secondary structure predictions or assignments.
The format is like:
.Sp
.Vb 5
\&  # speculative secondary structure assignments
\&  secondary structure
\&  5 - 30 h
\&  37 e
\&  40-45 e 5  # This is a very unreliable guess
.Ve
.RS 4
.IP "*" 4
This means that residues 5 to 30 are helix.
Residue 37 is sheet (extended).
Residues 40 to 45 are sheet (extended) and they have a confidence
level of 5.
.IP "*" 4
The first non blank line must say \*(L"secondary structure\*(R". This is
not optional. It is used to recognise the file format.
.IP "*" 4
Confidence levels can be given from 0 to 9. Zero means there is
no confidence. 9 means you are very confident. This number must
be an integer. There is no way to give a more detailed number.
.IP "*" 4
Confidence levels are optional. The default is confidence=9.
.IP "*" 4
Anything after a hash \f(CW\*(C`#\*(C'\fR is a comment.
.IP "*" 4
Blank lines are ignored.
.RE
.RS 4
.RE
.SH "AUTHORS"
.IX Header "AUTHORS"
Alphabetically... Thomas Huber, James B. Procter, Andrew E. Torda.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
coding.pod contains rules for adding to wurst.
