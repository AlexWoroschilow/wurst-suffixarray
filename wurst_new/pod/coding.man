.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "CODING 1"
.TH CODING 1 "2007-06-28" "perl v5.8.6" "User Contributed Perl Documentation"
.SH "NAME"
Code \- notes and coding rules
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The documentation for using wurst lives in \fIwurst.pod\fR. This
is a description of internals, conventions and how to change the code.
.SH "Layout"
.IX Header "Layout"
.IP "Philosophy" 4
.IX Item "Philosophy"
Have a look at some example files. There is a standard layout for
making functions stand out.  Please do not use your own layout,
even if it is prettier.  The aim is consistency and
predictability.
.IP "Tabs" 4
.IX Item "Tabs"
There are \fBno\fR tab characters. Use spaces. Use four spaces to
indent in functions and loops.
.IP "Indentation" 4
.IX Item "Indentation"
Indentation is almost pure Kernighan and Ritchie with four
spaces.
.IP "Line size" 4
.IX Item "Line size"
Try to make code readable in a window of 80 columns or printed
page of 80 columns.  This may mean shortening your line or
breaking it in a place you think makes it more readable for
others.
.IP "Version control" 4
.IX Item "Version control"
All the files have lines like this:
.Sp
.Vb 4
\&  #if !defined (lint) && !defined (DONT_SEE_RCS)
\&      static const char *rcsid =
\&      "$Id: coding.pod,v 1.11 2006/02/18 14:14:24 torda Exp $";
\&  #endif /* !defined (lint) && !defined (DONT_SEE_RCS) */
.Ve
.Sp
These come after the #include directives.
.IP "Function headings" 4
.IX Item "Function headings"
Begin every function as in the examples. Do not use your own
style, even if you think yours is better. Every function begins:
.Sp
.Vb 7
\&    /* ---------------- foobar  -----------------------------------
\&     * This function takes an argument and makes coffee.
\&     */
\&    static int
\&    foobar (int zot) 
\&    {
\&        ....
.Ve
.Sp
To list the properties:
.RS 4
.IP "* the comment style at the start should be respected, including the little stars and the empty column." 4
.IX Item "the comment style at the start should be respected, including the little stars and the empty column."
.PD 0
.IP "* function type on its own line" 4
.IX Item "function type on its own line"
.IP "* the opening brace is on its own line" 4
.IX Item "the opening brace is on its own line"
.RE
.RS 4
.RE
.IP "Punctuation" 4
.IX Item "Punctuation"
.PD
There should usually be a space after punctuation, for exactly
the same reasons as in English (helping
readability). Commas and semi-colons definitely want to be
followed by a space.
.Sp
Do not write
.Sp
.Vb 1
\&    for (a=0;a<lim;a++){
.Ve
.Sp
Do
.Sp
.Vb 1
\&    for (a = 0; a < lim; a++) {
.Ve
.Sp
If the line is going to go beyone 79 spaces, delicately delete
spaces while trying to keep readability.
.IP "typedef" 4
.IX Item "typedef"
A typedef is useful for complicated structures.  In many other
places it obscures the meaning. In wurst, typedefs should never
go into function prototypes. If they do, then other files cannot
easily include the function prototype. Consider a very
complicated structure of type \f(CW\*(C`struct\ tree\*(C'\fR. In a header you
may write
.Sp
.Vb 2
\& struct tree;
\& int function (struct tree *t);
.Ve
.Sp
Then anyone can include it without needing the definition of
\&\f(CW\*(C`struct\ tree\*(C'\fR.
.Sp
If you write
.Sp
.Vb 1
\& int function (treestruct *t);
.Ve
.Sp
Then nobody can include it without seeing the \f(CW\*(C`typedef\*(C'\fR.
.IP "include files" 4
.IX Item "include files"
.RS 4
.PD 0
.IP "*" 4
.PD
Do not include files from other include files.
.IP "*" 4
Split the description of the internal structures from the
interface. Call the file with the internal structures, \f(CW\*(C`blah.h\*(C'\fR
and the one with the interface, \f(CW\*(C`blah_i.h\*(C'\fR.
.RE
.RS 4
.RE
.IP "boolean" 4
.IX Item "boolean"
Do not add your own type with a name like \*(L"boolean\*(R" for
true/false.  If you are talking about errors, use
\&\f(CW\*(C`EXIT_SUCCESS\*(C'\fR/\f(CW\*(C`EXIT_FAILURE\*(C'\fR since these are \s-1ANSI\s0 standard. If
you have a yes/no situation, then there is a header file with a
simple enumerated type in \fIyesno.h\fR.  The problem with your own
boolean is that it gets redefined by different people, \s-1TRUE\s0 and
\&\s-1FALSE\s0 often appear in unrelated header files and the most recent
C standard has its own idea about boolean types.
.SH "INTERNALS"
.IX Header "INTERNALS"
.Sh "Declarations"
.IX Subsection "Declarations"
.IP "Ordering" 4
.IX Item "Ordering"
The order in which you declare variables should make no
difference. On the compaq, at least within structures, the
compiler makes noise unless you order objects from largest to
smallest.  This avoids padding to get best alignment.
.IP "Function declarations" 4
.IX Item "Function declarations"
If a function can possibly be made static, it should be.  Symbols
should be no more visible than is necessary.  There are also
optimisation advantages (the compiler can assume a function is
local and generate only an inlined version).
.Sp
If you have a static function you must
.RS 4
.IP "*" 4
Not declare it, then define it and use it. Instead,
.IP "*" 4
You should define it once, before it is used.
.RE
.RS 4
.Sp
In other words, do
.Sp
.Vb 3
\& static int function (int arg) { ... }
\& ...
\& b = function (a);
.Ve
.Sp
Rather than
.Sp
.Vb 5
\& static int function (int arg);
\& ...
\& static int function (int arg) { ... }
\& ...
\& b = function (a);
.Ve
.Sp
Obviously this rule has to be broken if there is mutual
recursion.
.Sp
This rule exists for consistency (it is used in every file) and
to follow the principle that we should write things the minimum
number of times and lastly, to ensure that whenever possible, a
compiler is given all the information about a static function by
the time it is used.
.RE
.Sh "Return values and errors"
.IX Subsection "Return values and errors"
There are two aspects to this.
.IP "Error messages" 4
.IX Item "Error messages"
Generally, the C functions do not print out too much information
in case of error. They must, however, return an error code to the
interpreter. The C functions should use \f(CW\*(C`err_printf()\*(C'\fR to pass
on the result of \f(CW\*(C`strerror()\*(C'\fR/\f(CW\*(C`perror()\*(C'\fR. Typically, this means
the lower level C code will write something like \f(CW\*(C`no such file
or directory\*(C'\fR, but it is up to the interpreter/script to decide
whether or not to go on.
.IP "Return codes" 4
.IX Item "Return codes"
Most of the C code returns \f(CW\*(C`EXIT_SUCCESS\*(C'\fR if it is happy and
\&\f(CW\*(C`EXIT_FAILURE\*(C'\fR (as defined in \fIstdlib.h\fR). This leads to a
problem. \f(CW\*(C`EXIT_FAILURE\*(C'\fR may be defined as \f(CW1\fR, but the perl
interpreter usually takes \f(CW1\fR as indicating success. The
convention in this code is that
.RS 4
.IP "*" 4
The C code returns \f(CW\*(C`EXIT_SUCCESS\*(C'\fR/\f(CW\*(C`EXIT_FAILURE\*(C'\fR as it
pleases. The interface code (\fIWurst.xs\fR) handles swapping the
sense when necessary. So, if C code returns an error, the
interface code may do \f(CW\*(C`XSRETURN_UNDEF\*(C'\fR.
.RE
.RS 4
.RE
.Sh "Conventions and internal routines"
.IX Subsection "Conventions and internal routines"
Wurst code may not call any of the following directly.
.IP "\fIprintf()\fR" 4
.IX Item "printf()"
.PD 0
.IP "\fIfprintf()\fR" 4
.IX Item "fprintf()"
.PD
At least not to stderr.
.IP "\fImalloc()\fR" 4
.IX Item "malloc()"
.PP
There are some general areas to think about.
.IP "printing" 4
.IX Item "printing"
Functions should not print to stdout or stderr
directly. Everything should go via \f(CW\*(C`err_printf()\*(C'\fR or
\&\f(CW\*(C`mprintf()\*(C'\fR or \f(CW\*(C`mfprintf()\*(C'\fR.
.Sp
If you have to print, you code must include
.Sp
#include \*(L"mprintf.h\*(R"
.RS 4
.IP "\fImprintf()\fR" 4
.IX Item "mprintf()"
Takes exactly the same arguments as \f(CW\*(C`printf()\*(C'\fR.
.IP "\fImfprint()\fR" 4
.IX Item "mfprint()"
Exactly the same as \f(CW\*(C`fprintf()\*(C'\fR.
.IP "\fIerr_printf()\fR" 4
.IX Item "err_printf()"
This is a replacement for \f(CW\*(C`fprintf(stderr,\ "blah")\*(C'\fR, but
it is not a direct wrapper. The convention is
.Sp
.Vb 11
\& #include <stdio.h>
\& #include "mprintf.h"
\&    ...
\& int
\& foo_bar (...)
\& {
\&     const char *this_sub = "foo_bar";
\&     ...
\&     if (error)
\&         err_printf (this_sub, "blah %s message\en", args);
\& }
.Ve
.Sp
This will result in a printing to something like stderr a
string like
.Sp
.Vb 1
\& Function foo_bar: blah args messsage
.Ve
.IP "\fImputchar()\fR" 4
.IX Item "mputchar()"
.PD 0
.IP "\fImfputc()\fR" 4
.IX Item "mfputc()"
.IP "\fImputs()\fR" 4
.IX Item "mputs()"
.IP "\fImfputs()\fR" 4
.IX Item "mfputs()"
.IP "\fImperror()\fR" 4
.IX Item "mperror()"
.PD
All these functions with names like \fImxxx()\fR, behave exactly as \fIxxx()\fR.
.RE
.RS 4
.RE
.IP "Passing strings to interpreter" 4
.IX Item "Passing strings to interpreter"
If you have a static string to pass back to the interpreter,
declare the function as
.Sp
.Vb 2
\& char *
\& some_func (..)
.Ve
.Sp
and all will be well. This. however, is the exception. Normally,
there is a string to be printed out and it has been dynamically
allocated. After the interpreter has finished with the string, it
should be \fIfree()\fR'd. There are two ways to go about this.
.RS 4
.IP "* perls \s-1SV\s0 mechanism" 4
.IX Item "perls SV mechanism"
.PD 0
.IP "* our internal \fIscr_xxx()\fR mechanism" 4
.IX Item "our internal scr_xxx() mechanism"
.RE
.RS 4
.PD
.Sp
Both the approaches are fine, but perhaps the first (perl's
mechanism) should be preferred from now on.
.Sp
Imagine your function allocates space for a string, writes
something into it and you want the interpreter to be able to
print it out.
.Sp
In the C code, declare your function returning char * like
.Sp
.Vb 7
\&    char *
\&    my_func (...)
\&    {
\&        char *x = E_MALLOC (sizeof (x[0] * length);
\&        strcpy (x, "something");
\&        return x;
\&    }
.Ve
.Sp
Then, in the file, \fIsomething.xs\fR, use an interface like
.Sp
\&\s-1SV\s0 *
my_func (a)
        int a;
    \s-1CODE:\s0
        {
            char *s = my_func(...);
            \s-1RETVAL\s0 = newSVpv (s, 0);
            free (s);
        }
    \s-1OUTPUT:\s0
        \s-1RETVAL\s0
.Sp
This will copy the string into a \f(CW\*(C`SV\*(C'\fR which the interpreter
knows how to deal with. We can immediately \fIfree()\fR the pointer
from our function.
.Sp
The second method is to use the scratch space routines,
\&\f(CW\*(C`scr_printf()\*(C'\fR like this.
.Sp
.Vb 1
\&    #include "scratch.h"
.Ve
.Sp
.Vb 5
\&    char *s;
\&    scr_reset();
\&    s = scr_printf ("blah %s\en", foo);
\&    s = scr_printf ("more text\en");
\&    return s;
.Ve
.Sp
The first call \f(CW\*(C`scr_reset()\*(C'\fR is necessary to tell our scratch
space to free any old strings. Subsequent calls append the
strings.
.RE
.IP "Memory allocation and malloc" 4
.IX Item "Memory allocation and malloc"
Do not call \f(CW\*(C`malloc()\*(C'\fR. Instead, call the macro
\&\f(CW\*(C`E_MALLOC()\*(C'\fR. This takes exactly the same arguments as
\&\f(CW\*(C`malloc()\*(C'\fR, but expands to print out the file and line number
if \f(CW\*(C`malloc()\*(C'\fR fails.
.Sp
It is a conscious design decision that we do not do any error
recovery there. If we run out of memory, we are cactus.
.Sh "Memory allocation philosophy and responsibility"
.IX Subsection "Memory allocation philosophy and responsibility"
Most of the time, memory is \fImalloc()\fR'd and \fIfree()\fR'd at the
same level of code. There is a major exception to
this. Objects which are passed back to the interpreter rely on
the interpreter's garbage collection. You must declare and
appropriate routine like \fIfoo_blah_DESTROY()\fR. This will be
called by the interpreter when the reference count for the
object goes to zero.  This routine must clean up any allocated
space.
.PP
This approach works well for objects like score
matrices. These are allocated once. Although their contents
may be manipulated, they do not move. Other objects, such as
sequence arrays may grow or shrink and move about as
determined by calls to \fIE_REALLOC()\fR. This means we have an
extra level of redirection and the interpreter is actually
given a pointer to a pointer to a sequence array.
.Sh "Score matrix storage"
.IX Subsection "Score matrix storage"
The score matrix for two objects of size \fBM\fR and \fBN\fR is of
size, \fB(M\ +\ 2)\ *\ (N\ +\ 2)\fR. The reason is that it is easier
to do special treatment of ends and end gaps this way.  This
means one has to be careful when coding around the score
matrices.
.Sh "Sequences and sequence arrays"
.IX Subsection "Sequences and sequence arrays"
In an early version, functions operated on arrays of
sequences. This is being phased out. Some functions may still
be able to handle arrays of sequences, mainly for getting
sequences in \s-1FASTA\s0 format.
.Sh "Structures and special rules"
.IX Subsection "Structures and special rules"
.IP "struct seq" 4
.IX Item "struct seq"
.RS 4
.PD 0
.IP "size" 4
.IX Item "size"
.PD
These items hold a sequence. The size element holds the number of
residues, but the string is allocated for (n\ +\ 1) so we can
really treat it as a string with a null terminator.
.IP "format" 4
.IX Item "format"
Sequence strings can either be conventional, one-letter amino
acid names or in 'thomas' format. The strings have an enumerated
type to say what state they are in. If your code depends on some
format, then call the appropriate function to convert the string
from one style to the other. For example, score functions will
often force strings to '\s-1THOMAS\s0' format. Before printing, strings
will usually be converted to '\s-1PRINTABLE\s0' format.
.RE
.RS 4
.RE
.IP "struct coord" 4
.IX Item "struct coord"
The coordinate structure not only holds coordinates, it holds a
corresponding sequence in a \f(CW\*(C`struct seq\*(C'\fR containe within. The
number of elements in the coord and seq structures must be the
same.
.Sp
Within the coord structure, code may \fBnot\fR assume that the
secondary strucure (sec_s) is complete, nor the phi angles
(phi). If these are \s-1NULL\s0 pointers, it means they have not been
read up, calculated or filled out.  The \f(CW\*(C`coord_DESTROY\*(C'\fR routine
has a look to see if these are \s-1NULL\s0 pointers and calls \f(CW\*(C`free()\*(C'\fR
only if they are non\-NULL.
.IP "struct prob_vec" 4
.IX Item "struct prob_vec"
Probability vectors are complicated because
.RS 4
.IP "*" 4
They can be in the simple array or a compact format
.IP "*" 4
They may be normalised in two different ways.
.IP "*" 4
The number of sites and probability vectors may vary.
.RE
.RS 4
.Sp
In more detail
.IP "prob_vec data storage" 4
.IX Item "prob_vec data storage"
.RS 4
.PD 0
.IP "expanded" 4
.IX Item "expanded"
.PD
In expanded form, the data is in a dynamically allocated
2D array. In mship[a][b], the slower changing index, \f(CW\*(C`a\*(C'\fR is the
site in the protein. The faster, \f(CW\*(C`b\*(C'\fR, is the class index.
.IP "compressed" 4
.IX Item "compressed"
In the \f(CW\*(C`mship[a][b]\*(C'\fR example, most of the elements are near
zero. In the compressed form, \f(CW\*(C`cmpct_n\->cmpct_n\*(C'\fR is an array
where each element tells us how many non-zero probabilities are
associated with site \f(CW\*(C`a\*(C'\fR. For site \f(CW\*(C`i\*(C'\fR, \f(CW\*(C`cmpct_n[i]\*(C'\fR says how
many probabilities are stored in \f(CW\*(C`prob_vec\->cmpct_prob\*(C'\fR. For
each of those probabilities, there is a corresponding entry in
\&\f(CW\*(C`prob_vec\->cmpct_ndx\*(C'\fR which is the number (index) of the
associated class. The number of elements in \f(CW\*(C`cmpct_prob\*(C'\fR will be
the same as in \f(CW\*(C`cmpct_ndx\*(C'\fR.
.IP "protocol" 4
.IX Item "protocol"
If there is no compressed data, \f(CW\*(C`prob_vec\->cmpct_n\*(C'\fR must point
to \f(CW\*(C`NULL\*(C'\fR. If \f(CW\*(C`prob_vec\->cmpct_n\*(C'\fR is non\-null, the pointer
will be assumed valid. If there is no expanded data,
\&\f(CW\*(C`prob_vec\->mship\*(C'\fR must point to \f(CW\*(C`NULL\*(C'\fR.
.RE
.RS 4
.RE
.IP "prob_vec normalisation" 4
.IX Item "prob_vec normalisation"
In terms of probabilities, the vector should be normalised so
that all the entries sum to 1.0. When comparing objects, we want
to treat the probability vectors as vectors of unit length, so we
can take the dot product in order to see the similarity. We also
have to allow for not knowing the state of our vectors. These
three situations are coded for by setting
\&\f(CW\*(C`prob_vec\->norm_type\*(C'\fR to 
.RS 4
.IP "*" 4
\&\f(CW\*(C`PVEC_TRUE_PROB\*(C'\fR
.IP "*" 4
\&\f(CW\*(C`PVEC_UNIT_VEC\*(C'\fR
.IP "*" 4
\&\f(CW\*(C`PVEC_CRAP\*(C'\fR
.RE
.RS 4
.RE
.IP "prob_vec number of sites / vectors" 4
.IX Item "prob_vec number of sites / vectors"
Describe the number of sites.
.RE
.RS 4
.RE
.SH "ADDING WURST"
.IX Header "ADDING WURST"
To add a function to wurst, you have to add something to
.IP "Wurst/Wurst.xs" 4
.IX Item "Wurst/Wurst.xs"
This is the C/perl interface
.IP "Wurst/Wurst.pm" 4
.IX Item "Wurst/Wurst.pm"
This advertises the symbols which the scripts can use.
.IP "The C file" 4
.IX Item "The C file"
The actual code to be called.
.IP "pod/wurst.pod" 4
.IX Item "pod/wurst.pod"
This is the documentation.
.PP
In more detail.
If you want to add a function, \fBdo_stuff\fR which acts on
something of type \fBthing_struct\fR, then do at least the
following.
.Sh "C code"
.IX Subsection "C code"
In \fIdo_stuff.c\fR, or wherever, define the function like
.PP
.Vb 4
\&  int
\&  do_stuff (struct thing_struct *thing) {
\&     ....
\&  }
.Ve
.PP
In \fIdo_stuff.h\fR, prototype the function interface like
.PP
.Vb 1
\&  int do_stuff (struct thing_struct *thing);
.Ve
.PP
Don't define the structure here. It is not necessary for the
perl interface to see structure internals.
.Sh "\s-1XS\s0 code"
.IX Subsection "XS code"
In Wurst/Wurst.xs, add
.PP
.Vb 1
\&  #include "do_stuff.h"
.Ve
.PP
and a typedef
.PP
.Vb 1
\&  typedef struct thing_struct Thing_struct;
.Ve
.PP
The capitalisation is not a joke. Perl likes it.
Finally, still in \fIWurst/Wurst.xs\fR, add the function
interface,
.PP
.Vb 3
\&  int
\&  do_stuff (x)
\&      Thing_struct *x;
.Ve
.Sh ".pm code"
.IX Subsection ".pm code"
Go to \fIWurst.pm\fR. Find the \f(CW@EXPORT\fR section and add
\&\fBdo_stuff\fR.
.Sh ".pod documentation"
.IX Subsection ".pod documentation"
Go to \fIpod/wurst.pod\fR and add a description of the new
function under the heading, \fB\s-1FUNCTIONS\s0\fR
.PP
If the function returns some data type back to the
interpreter, add a mention of that data type as well.
.SH "DEBUGGING"
.IX Header "DEBUGGING"
.Sh "General debugging"
.IX Subsection "General debugging"
There are two kinds of debugging:
.IP "perl debugging" 4
.IX Item "perl debugging"
This is not so interesting. Use the perl debugger.
.IP "debugging the C code" 4
.IX Item "debugging the C code"
This is more fun and discussed below.
.PP
Wurst is coded as a perl extension, but perl does not have
debugging symbols. During development, we will typically
compile the extension with \f(CW\*(C`\-g\*(C'\fR. The problem is that you
cannot set breakpoints since at program load time, the perl
extension (a dynamically loaded library) is not there and the
debugger does not see a symbol table.
.PP
This is not a terrible problem. The trick is to send a little
signal after the program has started, but before the
breakpoint. There are two ways to do this.
.IP "signal from perl" 4
.IX Item "signal from perl"
Somewhere early in the perl script, before entering the function
where you want a breakpoint, insert
.Sp
.Vb 2
\&    $SIG{TRAP} = 'IGNORE';
\&    kill 'TRAP', $$;
.Ve
.Sp
You could also set \f(CW$SIG{TRAP}\fR to point to some function of
your own.
.Sp
These lines say that we will ignore \s-1TRAP\s0 signals.  Then the code
sends a \s-1TRAP\s0 to itself.  The debugger notices the signal and
gives you a command prompt. Now, the dynamic library is loaded
and breakpoints can be set. This works with either \fBgdb\fR or
\&\fBdbx\fR.
.Sp
The nice aspect of this approach is that when one is not
debugging, the script runs fine. The signal is sent, but
ignored.
.IP "signal from C" 4
.IX Item "signal from C"
Sometimes one knows pretty well which function is going to be
a problem, and where one wants to look closely. We can use the
same mechanism by calling \f(CW\*(C`kill()\*(C'\fR from the C code. The
easiest way to do this is to find the file of interest.  At
the top of the file,
.Sp
.Vb 1
\&    #include "dbg.h"
.Ve
.Sp
In the subroutine of interest, insert a line
.Sp
.Vb 1
\&    breaker();
.Ve
.Sp
This little function just gets out the current process \s-1ID\s0 and
sends it a trap'able signal. The debugger will give you a command
prompt inside the \fIbreaker()\fR function which can be quickly stepped
out of.
.Sh "Memory debugging"
.IX Subsection "Memory debugging"
This is a challenge. One wants to work with a debugging
\&\f(CW\*(C`malloc()\*(C'\fR library, which looks for leaks and so on. When
building perl, it offers you the use of its own \f(CW\*(C`malloc()\*(C'\fR
library or the system one. It is probably useful to build perl
with the system library.
The
memory checking under \f(CW\*(C`dbx\*(C'\fR on Solaris works fine. Getting an
add-on library like \fBelectric fence\fR to work under solaris is
a bore. Wild use of the \s-1LD_PRELOAD\s0 environment variable
results in a program which gobbles up all available
memory. Under linux, it seems to be no problem to link
\&\fBelectric fence\fR in.
.PP
We assume that perl itself is free of leaks and we only want to
instrument our library.
.SH "Rules"
.IX Header "Rules"
Please follow these rules when writing wurst code.
.Sh "Function interfaces"
.IX Subsection "Function interfaces"
Keep the definition of the interface minimal and separate from
the definition of the innards. If you have a C file call
\&\fIfoo.c\fR, then
.IP "\(bu" 4
Put the public interface in \fIfoo_i.h\fR
.IP "\(bu" 4
Put the innnards in a file like \fIfoo.h\fR
.PP
For example
.PP
You may have some code like
.PP
.Vb 4
\&    struct cow {
\&        int legs;
\&        float weight;
\&    };
.Ve
.PP
.Vb 5
\&    int
\&    print_cow ( struct cow * daisy)
\&    {
\&        ....
\&    }
.Ve
.PP
Now there are a few files which have to know the innards of a
\&\f(CW\*(C`struct\ cow\*(C'\fR and others which will want to call
\&\fIprint_cow()\fR.
In this case, create a file \fIcow.h\fR which defines the
structure:
.PP
.Vb 4
\&    struct cow {
\&        int legs;
\&        float weight;
\&    };
.Ve
.PP
and in a separate file, \fIcow_i.h\fR,
.PP
.Vb 2
\&    struct cow;
\&    int print_cow (struct cow *c);
.Ve
.PP
Note:
.IP "\(bu" 4
Callers of \fIprint_cow()\fR do not need to see the innards of the
cow struct.
.IP "\(bu" 4
You should \fBnot\fR use a typedef in the function defintion or
prototype. If the code said
.Sp
.Vb 3
\&  struct cow {...}.
\&  typedef struct cow Cow;
\&  typedef struct cow *CowPtr;
.Ve
.Sp
then the prototype for \fIprint_cow()\fR would be
.Sp
.Vb 1
\&  int print_cow (CowPtr);
.Ve
.Sp
but then \fBevery\fR caller would need a definition of CowPtr.
Please do \fBnot\fR do that.
.Sh "Text and messages"
.IX Subsection "Text and messages"
.IP "mfprintf.c" 4
.IX Item "mfprintf.c"
Use the wrappers in \fImprintf.c\fR.
These may not do anything fancy now, but they allow us to wrap
our output at a later stage. For example, a Tcl extension is
not allowed to read or write to \fIstdout\fR\ /\ \fIstderr\fR. In
that case, the wrappers can do whatever is necessary to get
\&\fIprintf()\fR, \fIfprintf()\fR functions.
.IP "File Opening" 4
.IX Item "File Opening"
It is so frequent that we call \fIfopen()\fR with an error message,
that this is now in the wrapper, \fImfopen()\fR in \fIfio.c\fR. Use
.Sp
.Vb 2
\& #include "fio.h"
\& FILE * mfopen (const char *fname, const char *mode, const char *s)
.Ve
.Sp
where \fBfname\fR and \fBmode\fR are as for \fIfopen()\fR and \fBs\fR is a
string which will go into error messages. Typically, this will
be the name of the caller.
.IP "File Reading and Caching" 4
.IX Item "File Reading and Caching"
We have a hook to ask the \s-1OS\s0 not not to cache a file after
reading it for opening. Use the function \f(CW\*(C`file_no_cache(fp)\*(C'\fR on
the \s-1FILE\s0 pointer, \f(CW\*(C`fp\*(C'\fR. This somtimes makes a surprising difference in
performance. When reading a library of structures or profiles,
wurst may read almost 10000 files sequentially. The \s-1OS\s0 tries to
cache each one, although they will not be read again. The damage
is that it pushes useful pages such as other people's programs
out of the cache.  The function \f(CW\*(C`file_no_cache()\*(C'\fR is a wrapper
around a posix function which may not be present, so the wrapper
checks appropriate \f(CW\*(C`#define\*(C'\fRd values and is a no-op if the posix
functions do not seem to be present. A typical usage would be,
    if ((fp = mfopen (fname, \*(L"r\*(R", this_sub)) == \s-1NULL\s0)
        return \s-1NULL\s0;
.Sp
.Vb 6
\&    {
\&        int tmp;
\&        const char *s = "Turning off caching for %s:\en\e"%s\e"\en";
\&        if ((tmp = file_no_cache(fp)) != 0)
\&            err_printf (this_sub, s, fname, strerror (tmp));
\&    }
.Ve
.Sp
\&\s-1RETURN\s0 value is zero on success or \f(CW\*(C`errno\*(C'\fR on failure.
.IP "Reading lines from files" 4
.IX Item "Reading lines from files"
Very often, we want to read a line from a file, hopping over
blank lines and lines that begin with a hash (#).
Do not write another function to do this.
.Sp
.Vb 2
\& #include "misc.h"
\& get_nline (FILE *fp, char *buf, int *nr_line, size_t maxbuf)
.Ve
.Sp
Reads a line from fp. into buffer buf whose size is given by
maxbuf.
nr_line points to a line counter. \fIget_nline()\fR will increment
the variable on every line read.
.Sp
The routine throws away anything on a line after the hash (#)
character, so you can have inline comments.
.Sh "amino acids"
.IX Subsection "amino acids"
There are a couple of common conversions for amino acid names
and types. We may go from one to three letter codes and,
internally, from Thomas to standard one letter codes. All
functions for this kind of thing live in \fIamino_a.c\fR.
.Sh "memory allocation"
.IX Subsection "memory allocation"
.IP "standard \fImalloc()\fR" 4
.IX Item "standard malloc()"
All memory allocation must be done through the macros
\&\fB\f(BIE_MALLOC()\fB\fR and \fB\f(BIE_REALLOC()\fB\fR which live in
\&\fIe_malloc.c\fR. They take the standard arguments and return the
standard results, but, on failure, print out a line saying
where the error occurred, how much memory was requested and
then they die. This is generally good behaviour. Fancier code
could attempt error recovery, but usually when \fImalloc()\fR fails,
it means there was a code error.
.IP "matrices" 4
.IX Item "matrices"
All two dimensional matrices should be allocated via the
routines which have their roots in Thomas' code (which is
basically the outline given in Numerical Recipes).
.Sh "Function naming"
.IX Subsection "Function naming"
Some days, I call my functions \f(CW\*(C`print_thing()\*(C'\fR and
\&\f(CW\*(C`print_foo()\*(C'\fR. On others, I use \f(CW\*(C`foo_print()\*(C'\fR and
\&\f(CW\*(C`thing_print()\*(C'\fR.  Neither is better than the other. Here is
the rule...
.PP
Functions should be named \f(CW\*(C`thing_print()\*(C'\fR.
.PP
Note, I am aware of the disadvantage that you cannot see all
the things you can print or copy or whatever.
