/*
 * This file was generated automatically by xsubpp version 1.9508 from the
 * contents of Wurst.xs. Do not edit this file, edit Wurst.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Wurst.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "align_i.h"
#include "altscores.h"
#include "bad_angle.h"
#include "class_model.h"
#include "classifyStructure.h"
#include "cmp_dmat_i.h"
#include "coord.h"
#include "coord_i.h"
#include "coordinfo_i.h"
#include "dipep_i.h"
#include "geo_gap.h"
#include "lsqf.h"
#include "model.h"
#include "multialign.h"
#include "pair_set_chim.h"
#include "pair_set_i.h"
#include "pair_set_p_i.h"
#include "param_fx_i.h"
#include "pdbin_i.h"
#include "pdbout_i.h"
#include "prob_vec_i.h"
#include "read_ac.h"
#include "read_ac_i.h"
#include "read_ac_strct.h"
#include "read_ac_strct_i.h"
#include "read_blst.h"
#include "read_mat.h"
#include "read_sec_i.h"
#include "read_seq_i.h"
#include "rescore.h"
#include "score_fx_i.h"
#include "score_mat_i.h"
#include "score_probvec.h"
#include "score_sec_i.h"
#include "score_smat.h"
#include "scratch.h"
#include "sec_s_i.h"
#include "silly.h"
#include "scor_set.h"
#include "scor_set_i.h"
#include "seq.h"
#include "seq_i.h"

static int
not_here(char *s)
{
    croak("%s not implemented on this architecture", s);
    return -1;
}

static double
constant(char *name, int len, int arg)
{
    errno = 0;
    if (strEQ(name + 0, "WURST_H")) {    /*  removed */
#       ifdef WURST_H
        return WURST_H;
#       else
        errno = ENOENT;
        return 0;
#       endif
    }
    errno = EINVAL;
    return 0;
}

typedef struct aa_clssfcn       Aa_clssfcn;
typedef struct aa_strct_clssfcn Aa_strct_clssfcn ;
typedef struct dpt_list         Dpt_list;
typedef struct prob_vec         Prob_vec;
typedef struct sec_s_data       Sec_s_data;
typedef struct seq              Seq;
typedef struct seq_array        Seq_array;
typedef struct sub_mat          Sub_mat;
typedef struct score_mat        Score_mat;
typedef struct pair_set         Pair_set;
typedef struct coord            Coord;
typedef void                    Param;
typedef struct FXParam          FXParam;
typedef float                   RSParam;
typedef struct seqprof          Seqprof;
typedef struct scor_set         Scor_set;
typedef struct clssfcn          Clssfcn;
/*typedef struct RPoint     RPoint;*/

static const int PERL_OK = 1;
static const int PERL_FAIL = 0;

#line 102 "Wurst.c"
XS(XS_Wurst_constant); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_constant)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Wurst::constant(sv, arg)");
    {
#line 98 "Wurst.xs"
    STRLEN        len;
#line 112 "Wurst.c"
	SV *	sv = ST(0);
	char *	s = SvPV(sv, len);
	int	arg = (int)SvIV(ST(1));
	double	RETVAL;
	dXSTARG;
#line 104 "Wurst.xs"
    RETVAL = constant(s,len,arg);
#line 120 "Wurst.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_file_pre_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_file_pre_read)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::file_pre_read(fname)");
    {
	int	RETVAL;
	dXSTARG;
	const char *	fname = (const char *)SvPV_nolen(ST(0));
#line 113 "Wurst.xs"
        RETVAL = file_pre_read (fname);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 142 "Wurst.c"
    }
    XSRETURN(1);
}

XS(XS_Wurst_sec_s_data_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_sec_s_data_read)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::sec_s_data_read(fname)");
    {
	char *	fname = (char *)SvPV_nolen(ST(0));
	Sec_s_data *	RETVAL;

	RETVAL = sec_s_data_read(fname);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Sec_s_dataPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_sec_s_data_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_sec_s_data_string)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::sec_s_data_string(sec_s_data)");
    {
	Sec_s_data *	sec_s_data;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Sec_s_dataPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sec_s_data = INT2PTR(Sec_s_data *,tmp);
	}
	else
	    Perl_croak(aTHX_ "sec_s_data is not of type Sec_s_dataPtr");

	RETVAL = sec_s_data_string(sec_s_data);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_Sec_s_dataPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sec_s_dataPtr_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Sec_s_dataPtr::DESTROY(sec_s_data)");
    {
	Sec_s_data *	sec_s_data;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sec_s_data = INT2PTR(Sec_s_data *,tmp);
	}
	else
	    Perl_croak(aTHX_ "sec_s_data is not a reference");
#line 135 "Wurst.xs"
        sec_s_data_destroy (sec_s_data);
#line 205 "Wurst.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_Wurst_seq_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_seq_read)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::seq_read(fname)");
    {
	char *	fname = (char *)SvPV_nolen(ST(0));
	Seq *	RETVAL;

	RETVAL = seq_read(fname);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "SeqPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_seq_from_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_seq_from_string)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::seq_from_string(s)");
    {
	char *	s = (char *)SvPV_nolen(ST(0));
	Seq *	RETVAL;

	RETVAL = seq_from_string(s);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "SeqPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_seq_get_1); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_seq_get_1)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Wurst::seq_get_1(ps_a, n)");
    {
	Seq_array **	ps_a;
	size_t	n = (size_t)SvUV(ST(1));
	Seq *	RETVAL;

	if (sv_derived_from(ST(0), "Seq_arrayPtrPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ps_a = INT2PTR(Seq_array **,tmp);
	}
	else
	    Perl_croak(aTHX_ "ps_a is not of type Seq_arrayPtrPtr");

	RETVAL = seq_get_1(ps_a, n);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "SeqPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_seq_num); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_seq_num)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::seq_num(ps_a)");
    {
	Seq_array **	ps_a;
	size_t	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Seq_arrayPtrPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ps_a = INT2PTR(Seq_array **,tmp);
	}
	else
	    Perl_croak(aTHX_ "ps_a is not of type Seq_arrayPtrPtr");

	RETVAL = seq_num(ps_a);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_seq_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_seq_size)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::seq_size(seq)");
    {
	Seq *	seq;
	size_t	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    seq = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "seq is not of type SeqPtr");

	RETVAL = seq_size(seq);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_seq_print); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_seq_print)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::seq_print(seq)");
    {
	Seq *	seq;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    seq = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "seq is not of type SeqPtr");

	RETVAL = seq_print(seq);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_Wurst_seq_read_many); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_seq_read_many)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: Wurst::seq_read_many(fname, s_a = NULL)");
    {
	const char *	fname = (const char *)SvPV_nolen(ST(0));
	Seq_array **	s_a;
	Seq_array **	RETVAL;

	if (items < 2)
	    s_a = NULL;
	else {
	    if (sv_derived_from(ST(1), "Seq_arrayPtrPtr")) {
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		s_a = INT2PTR(Seq_array **,tmp);
	    }
	    else
		Perl_croak(aTHX_ "s_a is not of type Seq_arrayPtrPtr");
	}

	RETVAL = seq_read_many(fname, s_a);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Seq_arrayPtrPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_seq_print_many); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_seq_print_many)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::seq_print_many(ps_a)");
    {
	Seq_array **	ps_a;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Seq_arrayPtrPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ps_a = INT2PTR(Seq_array **,tmp);
	}
	else
	    Perl_croak(aTHX_ "ps_a is not of type Seq_arrayPtrPtr");

	RETVAL = seq_print_many(ps_a);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_Wurst_seq_duplicate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_seq_duplicate)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Wurst::seq_duplicate(src, n)");
    {
	Seq *	src;
	size_t	n = (size_t)SvUV(ST(1));
	Seq *	RETVAL;

	if (sv_derived_from(ST(0), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    src = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "src is not of type SeqPtr");

	RETVAL = seq_duplicate(src, n);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "SeqPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_SeqPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_SeqPtr_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: SeqPtr::DESTROY(seq)");
    {
	Seq *	seq;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    seq = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "seq is not a reference");
#line 185 "Wurst.xs"
        seq_destroy (seq);
#line 436 "Wurst.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_Seq_arrayPtrPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Seq_arrayPtrPtr_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Seq_arrayPtrPtr::DESTROY(s_a)");
    {
	Seq_array **	s_a;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s_a = INT2PTR(Seq_array **,tmp);
	}
	else
	    Perl_croak(aTHX_ "s_a is not a reference");
#line 193 "Wurst.xs"
        seq_array_destroy (s_a);
#line 458 "Wurst.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_Wurst_sub_mat_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_sub_mat_read)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::sub_mat_read(fname)");
    {
	const char *	fname = (const char *)SvPV_nolen(ST(0));
	Sub_mat *	RETVAL;

	RETVAL = sub_mat_read(fname);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Sub_matPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_sub_mat_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_sub_mat_string)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::sub_mat_string(s_m)");
    {
	Sub_mat *	s_m;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Sub_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s_m = INT2PTR(Sub_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "s_m is not of type Sub_matPtr");

	RETVAL = sub_mat_string(s_m);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_Wurst_sub_mat_shift); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_sub_mat_shift)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Wurst::sub_mat_shift(s_m, x)");
    {
	Sub_mat *	s_m;
	float	x = (float)SvNV(ST(1));
	Sub_mat *	RETVAL;

	if (sv_derived_from(ST(0), "Sub_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s_m = INT2PTR(Sub_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "s_m is not of type Sub_matPtr");

	RETVAL = sub_mat_shift(s_m, x);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Sub_matPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_sub_mat_scale); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_sub_mat_scale)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Wurst::sub_mat_scale(s_m, bot, top)");
    {
	Sub_mat *	s_m;
	int	bot = (int)SvIV(ST(1));
	int	top = (int)SvIV(ST(2));

	if (sv_derived_from(ST(0), "Sub_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s_m = INT2PTR(Sub_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "s_m is not of type Sub_matPtr");

	sub_mat_scale(s_m, bot, top);
    }
    XSRETURN_EMPTY;
}

XS(XS_Wurst_sub_mat_get_by_i); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_sub_mat_get_by_i)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Wurst::sub_mat_get_by_i(s_m, ndx1, ndx2)");
    {
	Sub_mat *	s_m;
	int	ndx1 = (int)SvIV(ST(1));
	int	ndx2 = (int)SvIV(ST(2));
	float	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Sub_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s_m = INT2PTR(Sub_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "s_m is not of type Sub_matPtr");

	RETVAL = sub_mat_get_by_i(s_m, ndx1, ndx2);
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_sub_mat_get_by_c); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_sub_mat_get_by_c)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Wurst::sub_mat_get_by_c(s_m, ndx1, ndx2)");
    {
	Sub_mat *	s_m;
	char	ndx1 = (char)*SvPV_nolen(ST(1));
	char	ndx2 = (char)*SvPV_nolen(ST(2));
	float	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Sub_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s_m = INT2PTR(Sub_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "s_m is not of type Sub_matPtr");

	RETVAL = sub_mat_get_by_c(s_m, ndx1, ndx2);
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_sub_mat_set_by_i); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_sub_mat_set_by_i)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: Wurst::sub_mat_set_by_i(s_m, ndx1, ndx2, f)");
    {
	Sub_mat *	s_m;
	int	ndx1 = (int)SvIV(ST(1));
	int	ndx2 = (int)SvIV(ST(2));
	float	f = (float)SvNV(ST(3));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Sub_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s_m = INT2PTR(Sub_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "s_m is not of type Sub_matPtr");
#line 239 "Wurst.xs"
        RETVAL = sub_mat_set_by_i (s_m, ndx1, ndx2, f);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 630 "Wurst.c"
    }
    XSRETURN(1);
}

XS(XS_Wurst_sub_mat_set_by_c); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_sub_mat_set_by_c)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: Wurst::sub_mat_set_by_c(s_m, ndx1, ndx2, f)");
    {
	Sub_mat *	s_m;
	char	ndx1 = (char)*SvPV_nolen(ST(1));
	char	ndx2 = (char)*SvPV_nolen(ST(2));
	float	f = (float)SvNV(ST(3));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Sub_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s_m = INT2PTR(Sub_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "s_m is not of type Sub_matPtr");
#line 252 "Wurst.xs"
        RETVAL = sub_mat_set_by_c (s_m, ndx1, ndx2, f);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 661 "Wurst.c"
    }
    XSRETURN(1);
}

XS(XS_Sub_matPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sub_matPtr_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Sub_matPtr::DESTROY(s_m)");
    {
	Sub_mat *	s_m;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s_m = INT2PTR(Sub_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "s_m is not a reference");
#line 264 "Wurst.xs"
        sub_mat_destroy (s_m);
#line 683 "Wurst.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_Wurst_coord_2_bin); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_2_bin)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Wurst::coord_2_bin(c, fname)");
    {
	Coord *	c;
	const char *	fname = (const char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "c is not of type CoordPtr");
#line 277 "Wurst.xs"
        RETVAL = coord_2_bin (c, fname);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 712 "Wurst.c"
    }
    XSRETURN(1);
}

XS(XS_Wurst_coord_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_name)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::coord_name(c)");
    {
	Coord *	c;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "c is not of type CoordPtr");

	RETVAL = coord_name(c);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_Wurst_coord_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_size)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::coord_size(c)");
    {
	Coord *	c;
	size_t	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "c is not of type CoordPtr");

	RETVAL = coord_size(c);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_coord_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_read)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::coord_read(fname)");
    {
	const char *	fname = (const char *)SvPV_nolen(ST(0));
	Coord *	RETVAL;

	RETVAL = coord_read(fname);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "CoordPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_coord_get_seq); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_get_seq)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::coord_get_seq(c)");
    {
	Coord *	c;
	Seq *	RETVAL;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "c is not of type CoordPtr");

	RETVAL = coord_get_seq(c);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "SeqPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_coord_has_sec_s); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_has_sec_s)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::coord_has_sec_s(c)");
    {
	Coord *	c;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "c is not of type CoordPtr");

	RETVAL = coord_has_sec_s(c);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_coord_get_sec_s); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_get_sec_s)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::coord_get_sec_s(c)");
    {
	Coord *	c;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "c is not of type CoordPtr");

	RETVAL = coord_get_sec_s(c);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_Wurst_coord_2_pdb); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_2_pdb)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: Wurst::coord_2_pdb(fname, c, seq = NULL)");
    {
	const char *	fname = (const char *)SvPV_nolen(ST(0));
	Coord *	c;
	Seq *	seq;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(1), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "c is not of type CoordPtr");

	if (items < 3)
	    seq = NULL;
	else {
	    if (sv_derived_from(ST(2), "SeqPtr")) {
		IV tmp = SvIV((SV*)SvRV(ST(2)));
		seq = INT2PTR(Seq *,tmp);
	    }
	    else
		Perl_croak(aTHX_ "seq is not of type SeqPtr");
	}
#line 313 "Wurst.xs"
        RETVAL = coord_2_pdb (fname, c, seq);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 890 "Wurst.c"
    }
    XSRETURN(1);
}

XS(XS_Wurst_coord_2_spdb); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_2_spdb)
{
    dXSARGS;
    if (items < 3 || items > 4)
	Perl_croak(aTHX_ "Usage: Wurst::coord_2_spdb(fname, c, scorset, seq = NULL)");
    {
	const char *	fname = (const char *)SvPV_nolen(ST(0));
	Coord *	c;
	Scor_set *	scorset;
	Seq *	seq;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(1), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "c is not of type CoordPtr");

	if (sv_derived_from(ST(2), "Scor_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    scorset = INT2PTR(Scor_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "scorset is not of type Scor_setPtr");

	if (items < 4)
	    seq = NULL;
	else {
	    if (sv_derived_from(ST(3), "SeqPtr")) {
		IV tmp = SvIV((SV*)SvRV(ST(3)));
		seq = INT2PTR(Seq *,tmp);
	    }
	    else
		Perl_croak(aTHX_ "seq is not of type SeqPtr");
	}
#line 326 "Wurst.xs"
        RETVAL = coord_2_spdb (fname, c, seq, scorset);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 939 "Wurst.c"
    }
    XSRETURN(1);
}

XS(XS_Wurst_coord_c_n_dist); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_c_n_dist)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: Wurst::coord_c_n_dist(c, i, j, sqrt_flag)");
    {
	Coord *	c;
	unsigned int	i = (unsigned int)SvUV(ST(1));
	unsigned int	j = (unsigned int)SvUV(ST(2));
	unsigned int	sqrt_flag = (unsigned int)SvUV(ST(3));
	float	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "c is not of type CoordPtr");

	RETVAL = coord_c_n_dist(c, i, j, sqrt_flag);
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_coord_calc_psi); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_calc_psi)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::coord_calc_psi(c)");
    {
	Coord *	c;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "c is not of type CoordPtr");

	coord_calc_psi(c);
    }
    XSRETURN_EMPTY;
}

XS(XS_Wurst_coord_calc_phi); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_calc_phi)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::coord_calc_phi(c)");
    {
	Coord *	c;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "c is not of type CoordPtr");

	coord_calc_phi(c);
    }
    XSRETURN_EMPTY;
}

XS(XS_Wurst_coord_psi); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_psi)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Wurst::coord_psi(c, j, shift_min)");
    {
	Coord *	c;
	const size_t	j = (const size_t)SvUV(ST(1));
	const float	shift_min = (float)SvNV(ST(2));
	float	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "c is not of type CoordPtr");
#line 356 "Wurst.xs"
       RETVAL = coord_psi (c, j, shift_min);
       if (RETVAL == BAD_ANGLE)
           XSRETURN_UNDEF;
#line 1036 "Wurst.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_coord_phi); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_phi)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Wurst::coord_phi(c, j, shift_min)");
    {
	Coord *	c;
	const size_t	j = (const size_t)SvUV(ST(1));
	const float	shift_min = (float)SvNV(ST(2));
	float	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "c is not of type CoordPtr");
#line 369 "Wurst.xs"
       RETVAL = coord_phi (c, j, shift_min);
       if (RETVAL == BAD_ANGLE)
           XSRETURN_UNDEF;
#line 1065 "Wurst.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_coord_geo_gap); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_geo_gap)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Wurst::coord_geo_gap(c, scale, max)");
    SP -= items;
    {
	Coord *	c;
	float	scale = (float)SvNV(ST(1));
	float	max = (float)SvNV(ST(2));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "c is not of type CoordPtr");
#line 381 "Wurst.xs"
    {
        unsigned int num_gap;
        int r;
        float quad, linear, logistic;
        SV *sv1 = &PL_sv_undef;
        SV *sv2 = &PL_sv_undef;
        SV *sv3 = &PL_sv_undef;
        SV *sv4 = &PL_sv_undef;
        r = coord_geo_gap (c, &quad, &linear, &logistic, &num_gap, scale, max);
        if (r == EXIT_FAILURE)
            XSRETURN_UNDEF;
        sv1 = newSVnv (quad);
        sv2 = newSVnv (linear);
        sv3 = newSVnv (logistic);
        sv4 = newSViv (num_gap);
        sv_2mortal (sv1);
        sv_2mortal (sv2);
        sv_2mortal (sv3);
        sv_2mortal (sv4);
        XPUSHs (sv1);
        XPUSHs (sv2);
        XPUSHs (sv3);
        XPUSHs (sv4);
    }
#line 1116 "Wurst.c"
	PUTBACK;
	return;
    }
}

XS(XS_Wurst_dme_thresh); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_dme_thresh)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: Wurst::dme_thresh(frac, c1, c2, thresh)");
    {
	float	frac;
	Coord *	c1;
	Coord *	c2;
	float	thresh = (float)SvNV(ST(3));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(1), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    c1 = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "c1 is not of type CoordPtr");

	if (sv_derived_from(ST(2), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    c2 = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "c2 is not of type CoordPtr");
#line 413 "Wurst.xs"
        RETVAL = dme_thresh (&frac, c1, c2, thresh);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 1155 "Wurst.c"
	sv_setnv(ST(0), (double)frac);
	SvSETMAGIC(ST(0));
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_pdb_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_pdb_read)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Wurst::pdb_read(fname, acq_c, chain)");
    {
	const char *	fname = (const char *)SvPV_nolen(ST(0));
	const char *	acq_c = (const char *)SvPV_nolen(ST(1));
	const char	chain = (char)*SvPV_nolen(ST(2));
	Coord *	RETVAL;

	RETVAL = pdb_read(fname, acq_c, chain);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "CoordPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_CoordPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_CoordPtr_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: CoordPtr::DESTROY(c)");
    {
	Coord *	c;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "c is not a reference");
#line 435 "Wurst.xs"
        coord_destroy (c);
#line 1199 "Wurst.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_Wurst_make_model); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_make_model)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Wurst::make_model(p, seq, coord)");
    {
	Pair_set *	p;
	Seq *	seq;
	Coord *	coord;
	Coord *	RETVAL;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    p = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "p is not of type Pair_setPtr");

	if (sv_derived_from(ST(1), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    seq = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "seq is not of type SeqPtr");

	if (sv_derived_from(ST(2), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    coord = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "coord is not of type CoordPtr");

	RETVAL = make_model(p, seq, coord);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "CoordPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_mc_run); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_mc_run)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Wurst::mc_run(fname, frag_len, max_iter)");
    {
	const char *	fname = (const char *)SvPV_nolen(ST(0));
	const int	frag_len = (const int)SvIV(ST(1));
	const int	max_iter = (const int)SvIV(ST(2));
	int	RETVAL;
	dXSTARG;

	RETVAL = mc_run(fname, frag_len, max_iter);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_model_pdb_num); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_model_pdb_num)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Wurst::model_pdb_num(mdl, resnum)");
    {
	Coord *	mdl;
	int	resnum = (int)SvIV(ST(1));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mdl = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "mdl is not of type CoordPtr");
#line 459 "Wurst.xs"
        RETVAL = model_pdb_num(mdl, resnum);
        if (RETVAL == -99999)
            XSRETURN_UNDEF;
#line 1285 "Wurst.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_model_res_num); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_model_res_num)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Wurst::model_res_num(mdl, mnum)");
    {
	Coord *	mdl;
	int	mnum = (int)SvIV(ST(1));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mdl = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "mdl is not of type CoordPtr");
#line 470 "Wurst.xs"
        RETVAL = model_res_num(mdl, mnum);
        if (RETVAL == -1)
          XSRETURN_UNDEF;
#line 1313 "Wurst.c"
    }
    XSRETURN(1);
}

XS(XS_Wurst_coord_2_pnlty); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_2_pnlty)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Wurst::coord_2_pnlty(c, f)");
    {
	Coord *	c;
	float	f = (float)SvNV(ST(1));
	float *	RETVAL;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "c is not of type CoordPtr");

	RETVAL = coord_2_pnlty(c, f);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "floatPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_score_mat_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_mat_new)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Wurst::score_mat_new(n_rows, n_cols)");
    {
	size_t	n_rows = (size_t)SvUV(ST(0));
	size_t	n_cols = (size_t)SvUV(ST(1));
	Score_mat *	RETVAL;

	RETVAL = score_mat_new(n_rows, n_cols);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Score_matPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_score_mat_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_mat_read)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::score_mat_read(fname)");
    {
	const char *	fname = (const char *)SvPV_nolen(ST(0));
	Score_mat *	RETVAL;

	RETVAL = score_mat_read(fname);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Score_matPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_score_mat_add); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_mat_add)
{
    dXSARGS;
    if (items < 3 || items > 4)
	Perl_croak(aTHX_ "Usage: Wurst::score_mat_add(mat1, mat2, scale, shift = 0.0)");
    {
	Score_mat *	mat1;
	Score_mat *	mat2;
	float	scale = (float)SvNV(ST(2));
	float	shift;
	Score_mat *	RETVAL;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mat1 = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "mat1 is not of type Score_matPtr");

	if (sv_derived_from(ST(1), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    mat2 = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "mat2 is not of type Score_matPtr");

	if (items < 4)
	    shift = 0.0;
	else {
	    shift = (float)SvNV(ST(3));
	}

	RETVAL = score_mat_add(mat1, mat2, scale, shift);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Score_matPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_score_mat_info); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_mat_info)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::score_mat_info(mat)");
    {
	Score_mat *	mat;
	float	min;
	float	max;
	float	av;
	float	std_dev;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mat = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "mat is not of type Score_matPtr");
#line 506 "Wurst.xs"
        score_mat_info (mat, &min, &max, &av, &std_dev);
#line 1439 "Wurst.c"
	XSprePUSH;	EXTEND(SP,4);
	PUSHs(sv_newmortal());
	sv_setnv(ST(0), (double)min);
	PUSHs(sv_newmortal());
	sv_setnv(ST(1), (double)max);
	PUSHs(sv_newmortal());
	sv_setnv(ST(2), (double)av);
	PUSHs(sv_newmortal());
	sv_setnv(ST(3), (double)std_dev);
    }
    XSRETURN(4);
}

XS(XS_Wurst_score_mat_scale); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_mat_scale)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Wurst::score_mat_scale(mat, scale)");
    {
	Score_mat *	mat;
	const float	scale = (float)SvNV(ST(1));
	Score_mat *	RETVAL;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mat = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "mat is not of type Score_matPtr");

	RETVAL = score_mat_scale(mat, scale);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Score_matPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_score_mat_shift); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_mat_shift)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Wurst::score_mat_shift(mat1, shift)");
    {
	Score_mat *	mat1;
	const float	shift = (float)SvNV(ST(1));
	Score_mat *	RETVAL;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mat1 = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "mat1 is not of type Score_matPtr");

	RETVAL = score_mat_shift(mat1, shift);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Score_matPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_score_mat_write); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_mat_write)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Wurst::score_mat_write(mat1, fname)");
    {
	Score_mat *	mat1;
	const char *	fname = (const char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mat1 = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "mat1 is not of type Score_matPtr");
#line 523 "Wurst.xs"
        RETVAL = score_mat_write (mat1, fname);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 1527 "Wurst.c"
    }
    XSRETURN(1);
}

XS(XS_Wurst_score_mat_diag_wipe); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_mat_diag_wipe)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Wurst::score_mat_diag_wipe(pair_set, smat)");
    {
	Pair_set *	pair_set;
	Score_mat *	smat;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pair_set = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "pair_set is not of type Pair_setPtr");

	if (sv_derived_from(ST(1), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    smat = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "smat is not of type Score_matPtr");

	score_mat_diag_wipe(pair_set, smat);
    }
    XSRETURN_EMPTY;
}

XS(XS_Wurst_score_mat_double_matrix); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_mat_double_matrix)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::score_mat_double_matrix(smat)");
    {
	Score_mat *	smat;
	Score_mat *	RETVAL;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    smat = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "smat is not of type Score_matPtr");

	RETVAL = score_mat_double_matrix(smat);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Score_matPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_score_mat_write_gnuplot); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_mat_write_gnuplot)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: Wurst::score_mat_write_gnuplot(smat, fname, protA, protB)");
    {
	Score_mat *	smat;
	const char *	fname = (const char *)SvPV_nolen(ST(1));
	const char *	protA = (const char *)SvPV_nolen(ST(2));
	const char *	protB = (const char *)SvPV_nolen(ST(3));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    smat = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "smat is not of type Score_matPtr");

	RETVAL = score_mat_write_gnuplot(smat, fname, protA, protB);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_score_dpt); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_dpt)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: Wurst::score_dpt(score_mat, seq1, seq2, d_p)");
    {
	Score_mat *	score_mat;
	Seq *	seq1;
	Seq *	seq2;
	Dpt_list *	d_p;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    score_mat = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "score_mat is not of type Score_matPtr");

	if (sv_derived_from(ST(1), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    seq1 = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "seq1 is not of type SeqPtr");

	if (sv_derived_from(ST(2), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    seq2 = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "seq2 is not of type SeqPtr");

	if (sv_derived_from(ST(3), "Dpt_listPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(3)));
	    d_p = INT2PTR(Dpt_list *,tmp);
	}
	else
	    Perl_croak(aTHX_ "d_p is not of type Dpt_listPtr");
#line 554 "Wurst.xs"
        RETVAL = score_dpt (score_mat, seq1, seq2, d_p);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 1659 "Wurst.c"
    }
    XSRETURN(1);
}

XS(XS_Wurst_score_prof_prof); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_prof_prof)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: Wurst::score_prof_prof(score_mat, sp1, sp2, subst_matrix)");
    {
	Score_mat *	score_mat;
	Seqprof *	sp1;
	Seqprof *	sp2;
	Sub_mat *	subst_matrix;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    score_mat = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "score_mat is not of type Score_matPtr");

	if (sv_derived_from(ST(1), "SeqprofPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    sp1 = INT2PTR(Seqprof *,tmp);
	}
	else
	    Perl_croak(aTHX_ "sp1 is not of type SeqprofPtr");

	if (sv_derived_from(ST(2), "SeqprofPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    sp2 = INT2PTR(Seqprof *,tmp);
	}
	else
	    Perl_croak(aTHX_ "sp2 is not of type SeqprofPtr");

	if (sv_derived_from(ST(3), "Sub_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(3)));
	    subst_matrix = INT2PTR(Sub_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "subst_matrix is not of type Sub_matPtr");
#line 567 "Wurst.xs"
        RETVAL = score_prof_prof (score_mat, sp1, sp2, subst_matrix);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 1711 "Wurst.c"
    }
    XSRETURN(1);
}

XS(XS_Wurst_score_smat); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_smat)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: Wurst::score_smat(score_mat, seq1, seq2, subst_matrix)");
    {
	Score_mat *	score_mat;
	Seq *	seq1;
	Seq *	seq2;
	Sub_mat *	subst_matrix;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    score_mat = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "score_mat is not of type Score_matPtr");

	if (sv_derived_from(ST(1), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    seq1 = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "seq1 is not of type SeqPtr");

	if (sv_derived_from(ST(2), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    seq2 = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "seq2 is not of type SeqPtr");

	if (sv_derived_from(ST(3), "Sub_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(3)));
	    subst_matrix = INT2PTR(Sub_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "subst_matrix is not of type Sub_matPtr");
#line 580 "Wurst.xs"
        RETVAL = score_smat (score_mat, seq1, seq2, subst_matrix);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 1763 "Wurst.c"
    }
    XSRETURN(1);
}

XS(XS_Wurst_score_sprof); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_sprof)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: Wurst::score_sprof(score_mat, sp, seq, subst_matrix)");
    {
	Score_mat *	score_mat;
	Seqprof *	sp;
	Seq *	seq;
	Sub_mat *	subst_matrix;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    score_mat = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "score_mat is not of type Score_matPtr");

	if (sv_derived_from(ST(1), "SeqprofPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    sp = INT2PTR(Seqprof *,tmp);
	}
	else
	    Perl_croak(aTHX_ "sp is not of type SeqprofPtr");

	if (sv_derived_from(ST(2), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    seq = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "seq is not of type SeqPtr");

	if (sv_derived_from(ST(3), "Sub_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(3)));
	    subst_matrix = INT2PTR(Sub_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "subst_matrix is not of type Sub_matPtr");
#line 593 "Wurst.xs"
        RETVAL = score_sprof (score_mat, sp, seq, subst_matrix);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 1815 "Wurst.c"
    }
    XSRETURN(1);
}

XS(XS_Wurst_score_fx); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_fx)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: Wurst::score_fx(score_mat, seq, coord, param)");
    {
	Score_mat *	score_mat;
	Seq *	seq;
	Coord *	coord;
	FXParam *	param;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    score_mat = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "score_mat is not of type Score_matPtr");

	if (sv_derived_from(ST(1), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    seq = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "seq is not of type SeqPtr");

	if (sv_derived_from(ST(2), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    coord = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "coord is not of type CoordPtr");

	if (sv_derived_from(ST(3), "FXParamPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(3)));
	    param = INT2PTR(FXParam *,tmp);
	}
	else
	    Perl_croak(aTHX_ "param is not of type FXParamPtr");
#line 607 "Wurst.xs"
        RETVAL = score_fx (score_mat, seq, coord, param);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 1867 "Wurst.c"
    }
    XSRETURN(1);
}

XS(XS_Wurst_score_fx_prof); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_fx_prof)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: Wurst::score_fx_prof(score_mat, sp, coord, param)");
    {
	Score_mat *	score_mat;
	Seqprof *	sp;
	Coord *	coord;
	FXParam *	param;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    score_mat = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "score_mat is not of type Score_matPtr");

	if (sv_derived_from(ST(1), "SeqprofPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    sp = INT2PTR(Seqprof *,tmp);
	}
	else
	    Perl_croak(aTHX_ "sp is not of type SeqprofPtr");

	if (sv_derived_from(ST(2), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    coord = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "coord is not of type CoordPtr");

	if (sv_derived_from(ST(3), "FXParamPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(3)));
	    param = INT2PTR(FXParam *,tmp);
	}
	else
	    Perl_croak(aTHX_ "param is not of type FXParamPtr");
#line 620 "Wurst.xs"
        RETVAL = score_fx_prof (score_mat, sp, coord, param);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 1919 "Wurst.c"
    }
    XSRETURN(1);
}

XS(XS_Wurst_score_sec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_sec)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Wurst::score_sec(score_mat, sec_s, coord)");
    {
	Score_mat *	score_mat;
	Sec_s_data *	sec_s;
	Coord *	coord;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    score_mat = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "score_mat is not of type Score_matPtr");

	if (sv_derived_from(ST(1), "Sec_s_dataPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    sec_s = INT2PTR(Sec_s_data *,tmp);
	}
	else
	    Perl_croak(aTHX_ "sec_s is not of type Sec_s_dataPtr");

	if (sv_derived_from(ST(2), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    coord = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "coord is not of type CoordPtr");
#line 633 "Wurst.xs"
        RETVAL = score_sec (score_mat, sec_s, coord);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 1963 "Wurst.c"
    }
    XSRETURN(1);
}

XS(XS_Wurst_param_rs_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_param_rs_read)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::param_rs_read(fname)");
    {
	const char *	fname = (const char *)SvPV_nolen(ST(0));
	RSParam *	RETVAL;

	RETVAL = param_rs_read(fname);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "RSParamPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_score_rs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_rs)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Wurst::score_rs(coord, params)");
    {
	Coord *	coord;
	RSParam *	params;
	float	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    coord = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "coord is not of type CoordPtr");

	if (sv_derived_from(ST(1), "RSParamPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    params = INT2PTR(RSParam *,tmp);
	}
	else
	    Perl_croak(aTHX_ "params is not of type RSParamPtr");

	RETVAL = score_rs(coord, params);
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_param_fx_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_param_fx_read)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::param_fx_read(fname)");
    {
	const char *	fname = (const char *)SvPV_nolen(ST(0));
	FXParam *	RETVAL;

	RETVAL = param_fx_read(fname);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "FXParamPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_RSParamPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_RSParamPtr_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: RSParamPtr::DESTROY(p)");
    {
	RSParam *	p;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    p = INT2PTR(RSParam *,tmp);
	}
	else
	    Perl_croak(aTHX_ "p is not a reference");
#line 660 "Wurst.xs"
        param_rs_destroy (p);
#line 2051 "Wurst.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_FXParamPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_FXParamPtr_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: FXParamPtr::DESTROY(f)");
    {
	FXParam *	f;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    f = INT2PTR(FXParam *,tmp);
	}
	else
	    Perl_croak(aTHX_ "f is not a reference");
#line 669 "Wurst.xs"
        FXParam_destroy(f);
#line 2073 "Wurst.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_Wurst_score_mat_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_mat_string)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Wurst::score_mat_string(scores, seq0, seq1)");
    {
	Score_mat *	scores;
	Seq *	seq0;
	Seq *	seq1;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    scores = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "scores is not of type Score_matPtr");

	if (sv_derived_from(ST(1), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    seq0 = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "seq0 is not of type SeqPtr");

	if (sv_derived_from(ST(2), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    seq1 = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "seq1 is not of type SeqPtr");

	RETVAL = score_mat_string(scores, seq0, seq1);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_Wurst_score_pvec_quadrifiedsmat); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_pvec_quadrifiedsmat)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Wurst::score_pvec_quadrifiedsmat(score_mat, pvec1, pvec2)");
    {
	Score_mat *	score_mat;
	Prob_vec *	pvec1;
	Prob_vec *	pvec2;
	Score_mat *	RETVAL;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    score_mat = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "score_mat is not of type Score_matPtr");

	if (sv_derived_from(ST(1), "Prob_vecPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    pvec1 = INT2PTR(Prob_vec *,tmp);
	}
	else
	    Perl_croak(aTHX_ "pvec1 is not of type Prob_vecPtr");

	if (sv_derived_from(ST(2), "Prob_vecPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    pvec2 = INT2PTR(Prob_vec *,tmp);
	}
	else
	    Perl_croak(aTHX_ "pvec2 is not of type Prob_vecPtr");

	RETVAL = score_pvec_quadrifiedsmat(score_mat, pvec1, pvec2);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Score_matPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_score_mat_sum_full); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_mat_sum_full)
{
    dXSARGS;
    if (items < 9 || items > 10)
	Perl_croak(aTHX_ "Usage: Wurst::score_mat_sum_full(rmat, scores, pgap_open, pgap_widen, qgap_open, qgap_widen, p_mult, q_mult, align_type, bias_set = NULL)");
    {
	Score_mat *	rmat;
	Score_mat *	scores;
	float	pgap_open = (float)SvNV(ST(2));
	float	pgap_widen = (float)SvNV(ST(3));
	float	qgap_open = (float)SvNV(ST(4));
	float	qgap_widen = (float)SvNV(ST(5));
	float *	p_mult;
	float *	q_mult;
	int	align_type = (int)SvIV(ST(8));
	Pair_set *	bias_set;
	Pair_set *	RETVAL;

	if (sv_derived_from(ST(1), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    scores = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "scores is not of type Score_matPtr");

	if (sv_derived_from(ST(6), "floatPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(6)));
	    p_mult = INT2PTR(float *,tmp);
	}
	else
	    Perl_croak(aTHX_ "p_mult is not of type floatPtr");

	if (sv_derived_from(ST(7), "floatPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(7)));
	    q_mult = INT2PTR(float *,tmp);
	}
	else
	    Perl_croak(aTHX_ "q_mult is not of type floatPtr");

	if (items < 10)
	    bias_set = NULL;
	else {
	    if (sv_derived_from(ST(9), "Pair_setPtr")) {
		IV tmp = SvIV((SV*)SvRV(ST(9)));
		bias_set = INT2PTR(Pair_set *,tmp);
	    }
	    else
		Perl_croak(aTHX_ "bias_set is not of type Pair_setPtr");
	}

	RETVAL = score_mat_sum_full(&rmat, scores, pgap_open, pgap_widen, qgap_open, qgap_widen, p_mult, q_mult, align_type, bias_set);
	sv_setref_pv(ST(0), "Score_matPtr", (void*)rmat);
	SvSETMAGIC(ST(0));
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Pair_setPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_floatPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_floatPtr_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: floatPtr::DESTROY(f)");
    {
	float *	f;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    f = INT2PTR(float *,tmp);
	}
	else
	    Perl_croak(aTHX_ "f is not a reference");
#line 707 "Wurst.xs"
       if (f)
           free (f);
#line 2236 "Wurst.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_Score_matPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Score_matPtr_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Score_matPtr::DESTROY(s)");
    {
	Score_mat *	s;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "s is not a reference");
#line 715 "Wurst.xs"
        score_mat_destroy (s);
#line 2258 "Wurst.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_Wurst_pair_set_chimera); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_pair_set_chimera)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Wurst::pair_set_chimera(s, c1, c2)");
    {
	Pair_set *	s;
	Coord *	c1;
	Coord *	c2;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "s is not of type Pair_setPtr");

	if (sv_derived_from(ST(1), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    c1 = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "c1 is not of type CoordPtr");

	if (sv_derived_from(ST(2), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    c2 = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "c2 is not of type CoordPtr");

	RETVAL = pair_set_chimera(s, c1, c2);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_Wurst_pair_set_coverage); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_pair_set_coverage)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Wurst::pair_set_coverage(s, n1, n2)");
    SP -= items;
    {
	Pair_set *	s;
	size_t	n1 = (size_t)SvUV(ST(1));
	size_t	n2 = (size_t)SvUV(ST(2));

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "s is not of type Pair_setPtr");
#line 738 "Wurst.xs"
    {
        char *c1, *c2;
        if (pair_set_coverage (s, n1, n2, &c1, &c2) ==  EXIT_FAILURE) {
            free (c1);
            free (c2);
            XSRETURN_UNDEF;
        }
        EXTEND(SP, 2);
        PUSHs(sv_2mortal(newSVpv (c1, 0)));
        PUSHs(sv_2mortal(newSVpv (c2, 0)));
        free (c1);
        free (c2);
    }
#line 2335 "Wurst.c"
	PUTBACK;
	return;
    }
}

XS(XS_Wurst_pair_set_gap); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_pair_set_gap)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Wurst::pair_set_gap(s, open_scale, widen_scale)");
    SP -= items;
    {
	Pair_set *	s;
	float	open_scale = (float)SvNV(ST(1));
	float	widen_scale = (float)SvNV(ST(2));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "s is not of type Pair_setPtr");
#line 758 "Wurst.xs"
    {
        float open_cost, widen_cost;
        int r;
        r = pair_set_gap (s, &open_cost, &widen_cost, open_scale, widen_scale);
        if (r == EXIT_FAILURE)
            XSRETURN_UNDEF;
        XPUSHs(sv_2mortal(newSVnv (open_cost)));
        XPUSHs(sv_2mortal(newSVnv (widen_cost)));
    }
#line 2371 "Wurst.c"
	PUTBACK;
	return;
    }
}

XS(XS_Wurst_pair_set_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_pair_set_string)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Wurst::pair_set_string(s, seq0, seq1)");
    {
	Pair_set *	s;
	Seq *	seq0;
	Seq *	seq1;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "s is not of type Pair_setPtr");

	if (sv_derived_from(ST(1), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    seq0 = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "seq0 is not of type SeqPtr");

	if (sv_derived_from(ST(2), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    seq1 = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "seq1 is not of type SeqPtr");

	RETVAL = pair_set_string(s, seq0, seq1);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_Wurst_multal_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_multal_string)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::multal_string(s)");
    {
	Pair_set *	s;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "s is not of type Pair_setPtr");

	RETVAL = multal_string(s);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_Wurst_pair_set_pretty_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_pair_set_pretty_string)
{
    dXSARGS;
    if (items < 3 || items > 5)
	Perl_croak(aTHX_ "Usage: Wurst::pair_set_pretty_string(s, seq0, seq1, sec_s_data = NULL, c2 = NULL)");
    {
	Pair_set *	s;
	Seq *	seq0;
	Seq *	seq1;
	Sec_s_data *	sec_s_data;
	Coord *	c2;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "s is not of type Pair_setPtr");

	if (sv_derived_from(ST(1), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    seq0 = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "seq0 is not of type SeqPtr");

	if (sv_derived_from(ST(2), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    seq1 = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "seq1 is not of type SeqPtr");

	if (items < 4)
	    sec_s_data = NULL;
	else {
	    if (sv_derived_from(ST(3), "Sec_s_dataPtr")) {
		IV tmp = SvIV((SV*)SvRV(ST(3)));
		sec_s_data = INT2PTR(Sec_s_data *,tmp);
	    }
	    else
		Perl_croak(aTHX_ "sec_s_data is not of type Sec_s_dataPtr");
	}

	if (items < 5)
	    c2 = NULL;
	else {
	    if (sv_derived_from(ST(4), "CoordPtr")) {
		IV tmp = SvIV((SV*)SvRV(ST(4)));
		c2 = INT2PTR(Coord *,tmp);
	    }
	    else
		Perl_croak(aTHX_ "c2 is not of type CoordPtr");
	}

	RETVAL = pair_set_pretty_string(s, seq0, seq1, sec_s_data, c2);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_Wurst_pair_set_get_alignment_indices); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_pair_set_get_alignment_indices)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Wurst::pair_set_get_alignment_indices(p_s, sequencenumber)");
    {
	Pair_set *	p_s;
	int	sequencenumber = (int)SvIV(ST(1));
	int	start;
	int	stop;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    p_s = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "p_s is not of type Pair_setPtr");
#line 791 "Wurst.xs"
                   pair_set_get_alignment_indices (p_s, sequencenumber, &start, &stop);
#line 2525 "Wurst.c"
	XSprePUSH;	EXTEND(SP,2);
	PUSHs(sv_newmortal());
	sv_setiv(ST(0), (IV)start);
	PUSHs(sv_newmortal());
	sv_setiv(ST(1), (IV)stop);
    }
    XSRETURN(2);
}

XS(XS_Wurst_pair_set_circularpermutated); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_pair_set_circularpermutated)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Wurst::pair_set_circularpermutated(p_s, prot1_len, prot2_len)");
    {
	Pair_set *	p_s;
	size_t	prot1_len = (size_t)SvUV(ST(1));
	size_t	prot2_len = (size_t)SvUV(ST(2));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    p_s = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "p_s is not of type Pair_setPtr");

	RETVAL = pair_set_circularpermutated(p_s, prot1_len, prot2_len);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_get_seq_id_simple); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_get_seq_id_simple)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Wurst::get_seq_id_simple(pair_set, s1, s2)");
    {
	int	RETVAL;
	dXSTARG;
	Pair_set *	pair_set;
	Seq *	s1;
	Seq *	s2;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pair_set = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "pair_set is not of type Pair_setPtr");

	if (sv_derived_from(ST(1), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    s1 = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "s1 is not of type SeqPtr");

	if (sv_derived_from(ST(2), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    s2 = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "s2 is not of type SeqPtr");

	RETVAL = get_seq_id_simple(pair_set, s1, s2);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_pair_set_score); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_pair_set_score)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::pair_set_score(s)");
    SP -= items;
    {
	Pair_set *	s;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "s is not of type Pair_setPtr");
#line 811 "Wurst.xs"
    {
        float score, score_smpl;
        SV *sv1 = &PL_sv_undef;
        SV *sv2 = &PL_sv_undef;
        if (pair_set_score (s, &score, &score_smpl) == EXIT_FAILURE)
            XSRETURN_UNDEF;
        sv1 = newSVnv (score);
        sv_2mortal (sv1);
        sv2 = newSVnv (score_smpl);
        sv_2mortal (sv2);
        XPUSHs (sv1);
        XPUSHs (sv2);
        RETVAL = 1;
    }
#line 2634 "Wurst.c"
	PUTBACK;
	return;
    }
}

XS(XS_Wurst_pair_set_extend); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_pair_set_extend)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: Wurst::pair_set_extend(s, n0, n1, ext_len)");
    {
	Pair_set *	s;
	size_t	n0 = (size_t)SvUV(ST(1));
	size_t	n1 = (size_t)SvUV(ST(2));
	int	ext_len = (int)SvIV(ST(3));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "s is not of type Pair_setPtr");

	RETVAL = pair_set_extend(s, n0, n1, ext_len);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Pair_setPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Pair_setPtr_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Pair_setPtr::DESTROY(s)");
    {
	Pair_set *	s;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    s = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "s is not a reference");
#line 839 "Wurst.xs"
        pair_set_destroy (s);
#line 2684 "Wurst.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_Wurst_func_int); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_func_int)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Wurst::func_int()");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = func_int();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_func_float); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_func_float)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Wurst::func_float()");
    {
	float	RETVAL;
	dXSTARG;

	RETVAL = func_float();
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_func_char); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_func_char)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Wurst::func_char()");
    {
	char *	RETVAL;
	dXSTARG;

	RETVAL = func_char();
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_Wurst_funcs1_char); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_funcs1_char)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::funcs1_char(in)");
    {
	char *	in = (char *)SvPV_nolen(ST(0));
	char *	RETVAL;
	dXSTARG;

	RETVAL = funcs1_char(in);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_Wurst_funcs2_char); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_funcs2_char)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Wurst::funcs2_char()");
    {
	char *	RETVAL;
	dXSTARG;

	RETVAL = funcs2_char();
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_Wurst_free_scratch); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_free_scratch)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Wurst::free_scratch()");
    {

	free_scratch();
    }
    XSRETURN_EMPTY;
}

XS(XS_Wurst_get_nbor); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_get_nbor)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::get_nbor(c)");
    {
	Coord *	c;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "c is not of type CoordPtr");

	RETVAL = get_nbor(c);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_get_solv_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_get_solv_data)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::get_solv_data(c)");
    {
	Coord *	c;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "c is not of type CoordPtr");

	RETVAL = get_solv_data(c);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_get_torsion_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_get_torsion_data)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::get_torsion_data(c)");
    {
	Coord *	c;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "c is not of type CoordPtr");

	RETVAL = get_torsion_data(c);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_blst_chk_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_blst_chk_read)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::blst_chk_read(f)");
    {
	const char *	f = (const char *)SvPV_nolen(ST(0));
	Seqprof *	RETVAL;

	RETVAL = blst_chk_read(f);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "SeqprofPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_seqprof_str); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_seqprof_str)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::seqprof_str(p)");
    {
	Seqprof *	p;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "SeqprofPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    p = INT2PTR(Seqprof *,tmp);
	}
	else
	    Perl_croak(aTHX_ "p is not of type SeqprofPtr");

	RETVAL = seqprof_str(p);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_Wurst_seqprof_get_seq); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_seqprof_get_seq)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::seqprof_get_seq(c)");
    {
	Seqprof *	c;
	Seq *	RETVAL;

	if (sv_derived_from(ST(0), "SeqprofPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Seqprof *,tmp);
	}
	else
	    Perl_croak(aTHX_ "c is not of type SeqprofPtr");

	RETVAL = seqprof_get_seq(c);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "SeqPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_SeqprofPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_SeqprofPtr_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: SeqprofPtr::DESTROY(p)");
    {
	Seqprof *	p;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    p = INT2PTR(Seqprof *,tmp);
	}
	else
	    Perl_croak(aTHX_ "p is not a reference");
#line 905 "Wurst.xs"
        seqprof_destroy (p);
#line 2937 "Wurst.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_Wurst_scor_set_fromvec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_scor_set_fromvec)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::scor_set_fromvec(dblvec)");
    SP -= items;
    {
	AV *	dblvec;
#line 916 "Wurst.xs"
       size_t s=0;
       size_t t;
       SV **d_el, *ssv;
       Scor_set *ss=NULL;
       double *dv;
#line 2957 "Wurst.c"

	if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0)))==SVt_PVAV)
	    dblvec = (AV*)SvRV(ST(0));
	else
	    Perl_croak(aTHX_ "dblvec is not an array reference");
#line 922 "Wurst.xs"
       t = 1+av_len(dblvec);
       if (t>0) {
         dv = malloc(sizeof(*dv)*t); /* vector passed to C function */
         while (s<t) {
           d_el=av_fetch(dblvec, s, 0);
           if (d_el && (SvNIOK(*d_el)))
             /* copy the values from the perl array */
             dv[s] = SvNV( *d_el );
           else
             dv[s] = 0.0; /* and do not complain if */
                         /* we're given garbage   */
           s++;
         }
         ss = scor_set_fromvec( t, dv);
         free(dv);
       }
       if (ss) {
           ssv = sv_newmortal();
           sv_setref_pv(ssv, "Scor_setPtr", (void *)ss);
           EXTEND(SP,1);
           PUSHs(ssv);
       } else {
           XSRETURN_UNDEF;
       }
#line 2988 "Wurst.c"
	PUTBACK;
	return;
    }
}

XS(XS_Wurst_scor_set_to_vec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_scor_set_to_vec)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::scor_set_to_vec(scoreset)");
    {
	Scor_set *	scoreset;
#line 955 "Wurst.xs"
          AV *av=Nullav;
          SV *a_el;
          size_t i=0;

#line 3007 "Wurst.c"
	AV *	RETVAL;

	if (sv_derived_from(ST(0), "Scor_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    scoreset = INT2PTR(Scor_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "scoreset is not of type Scor_setPtr");
#line 960 "Wurst.xs"
          if (scoreset!=NULL) {
             av = newAV();
             av_unshift(av, scoreset->n);
             while (i<scoreset->n) {
                a_el = sv_newref(newSVnv(scoreset->scores[i]));
                if (av_store(av, i, a_el)==NULL)
                     croak("scor_set_to_vec: av_store returned null - \
 where is my array ???");

                i++;
             }
           }
           RETVAL = av;
#line 3030 "Wurst.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_Wurst_scor_set_simpl); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_scor_set_simpl)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Wurst::scor_set_simpl(pairset, scoremat)");
    {
	Pair_set *	pairset;
	Score_mat *	scoremat;
	Scor_set *	RETVAL;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pairset = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "pairset is not of type Pair_setPtr");

	if (sv_derived_from(ST(1), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    scoremat = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "scoremat is not of type Score_matPtr");

	RETVAL = scor_set_simpl(pairset, scoremat);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Scor_setPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_scor_set_scale); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_scor_set_scale)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Wurst::scor_set_scale(scorset, scale)");
    {
	Scor_set *	scorset;
	float	scale = (float)SvNV(ST(1));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Scor_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    scorset = INT2PTR(Scor_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "scorset is not of type Scor_setPtr");
#line 987 "Wurst.xs"
        RETVAL = scor_set_scale( scorset, scale);
        if (RETVAL == EXIT_FAILURE)
          XSRETURN_UNDEF;
        else
          RETVAL = 1;
#line 3093 "Wurst.c"
    }
    XSRETURN(1);
}

XS(XS_Scor_setPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Scor_setPtr_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Scor_setPtr::DESTROY(p)");
    {
	Scor_set *	p;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    p = INT2PTR(Scor_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "p is not a reference");
#line 1000 "Wurst.xs"
        scor_set_destroy (p);
#line 3115 "Wurst.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_Wurst_prob_vec_info); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_prob_vec_info)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::prob_vec_info(pvec)");
    {
	Prob_vec *	pvec;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Prob_vecPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pvec = INT2PTR(Prob_vec *,tmp);
	}
	else
	    Perl_croak(aTHX_ "pvec is not of type Prob_vecPtr");

	RETVAL = prob_vec_info(pvec);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_Wurst_score_pvec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_score_pvec)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Wurst::score_pvec(score_mat, pvec1, pvec2)");
    {
	Score_mat *	score_mat;
	Prob_vec *	pvec1;
	Prob_vec *	pvec2;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    score_mat = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "score_mat is not of type Score_matPtr");

	if (sv_derived_from(ST(1), "Prob_vecPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    pvec1 = INT2PTR(Prob_vec *,tmp);
	}
	else
	    Perl_croak(aTHX_ "pvec1 is not of type Prob_vecPtr");

	if (sv_derived_from(ST(2), "Prob_vecPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    pvec2 = INT2PTR(Prob_vec *,tmp);
	}
	else
	    Perl_croak(aTHX_ "pvec2 is not of type Prob_vecPtr");
#line 1021 "Wurst.xs"
        RETVAL = score_pvec (score_mat, pvec1, pvec2);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 3183 "Wurst.c"
    }
    XSRETURN(1);
}

XS(XS_Wurst_prob_vec_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_prob_vec_size)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::prob_vec_size(pvec)");
    {
	Prob_vec *	pvec;
	size_t	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Prob_vecPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pvec = INT2PTR(Prob_vec *,tmp);
	}
	else
	    Perl_croak(aTHX_ "pvec is not of type Prob_vecPtr");

	RETVAL = prob_vec_size(pvec);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_prob_vec_length); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_prob_vec_length)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::prob_vec_length(pvec)");
    {
	Prob_vec *	pvec;
	size_t	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Prob_vecPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pvec = INT2PTR(Prob_vec *,tmp);
	}
	else
	    Perl_croak(aTHX_ "pvec is not of type Prob_vecPtr");

	RETVAL = prob_vec_length(pvec);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_prob_vec_copy); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_prob_vec_copy)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::prob_vec_copy(pvec)");
    {
	Prob_vec *	pvec;
	Prob_vec *	RETVAL;

	if (sv_derived_from(ST(0), "Prob_vecPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pvec = INT2PTR(Prob_vec *,tmp);
	}
	else
	    Perl_croak(aTHX_ "pvec is not of type Prob_vecPtr");

	RETVAL = prob_vec_copy(pvec);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Prob_vecPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_prob_vec_write); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_prob_vec_write)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Wurst::prob_vec_write(pvec, fname)");
    {
	Prob_vec *	pvec;
	const char *	fname = (const char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Prob_vecPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pvec = INT2PTR(Prob_vec *,tmp);
	}
	else
	    Perl_croak(aTHX_ "pvec is not of type Prob_vecPtr");
#line 1044 "Wurst.xs"
        RETVAL = prob_vec_write (pvec, fname);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 3284 "Wurst.c"
    }
    XSRETURN(1);
}

XS(XS_Wurst_prob_vec_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_prob_vec_read)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::prob_vec_read(fname)");
    {
	const char *	fname = (const char *)SvPV_nolen(ST(0));
	Prob_vec *	RETVAL;

	RETVAL = prob_vec_read(fname);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Prob_vecPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_prob_vec_duplicate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_prob_vec_duplicate)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Wurst::prob_vec_duplicate(pvec, k)");
    {
	Prob_vec *	pvec;
	size_t	k = (size_t)SvUV(ST(1));
	Prob_vec *	RETVAL;

	if (sv_derived_from(ST(0), "Prob_vecPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pvec = INT2PTR(Prob_vec *,tmp);
	}
	else
	    Perl_croak(aTHX_ "pvec is not of type Prob_vecPtr");

	RETVAL = prob_vec_duplicate(pvec, k);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Prob_vecPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Prob_vecPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Prob_vecPtr_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Prob_vecPtr::DESTROY(pvec)");
    {
	Prob_vec *	pvec;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pvec = INT2PTR(Prob_vec *,tmp);
	}
	else
	    Perl_croak(aTHX_ "pvec is not a reference");
#line 1064 "Wurst.xs"
        prob_vec_destroy (pvec);
#line 3348 "Wurst.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_Wurst_aa_strct_clssfcn_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_aa_strct_clssfcn_read)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Wurst::aa_strct_clssfcn_read(fname, error)");
    {
	const char *	fname = (const char *)SvPV_nolen(ST(0));
	const float	error = (float)SvNV(ST(1));
	Aa_strct_clssfcn *	RETVAL;

	RETVAL = aa_strct_clssfcn_read(fname, error);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Aa_strct_clssfcnPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_aa_strct_dump); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_aa_strct_dump)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::aa_strct_dump(ac)");
    {
	Aa_strct_clssfcn *	ac;

	if (sv_derived_from(ST(0), "Aa_strct_clssfcnPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ac = INT2PTR(Aa_strct_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "ac is not of type Aa_strct_clssfcnPtr");

	aa_strct_dump(ac);
    }
    XSRETURN_EMPTY;
}

XS(XS_Wurst_aa_strct_nclass); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_aa_strct_nclass)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::aa_strct_nclass(ac)");
    {
	Aa_strct_clssfcn *	ac;
	size_t	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Aa_strct_clssfcnPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ac = INT2PTR(Aa_strct_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "ac is not of type Aa_strct_clssfcnPtr");

	RETVAL = aa_strct_nclass(ac);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_aa_strct_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_aa_strct_size)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::aa_strct_size(ac)");
    {
	Aa_strct_clssfcn *	ac;
	size_t	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Aa_strct_clssfcnPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ac = INT2PTR(Aa_strct_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "ac is not of type Aa_strct_clssfcnPtr");

	RETVAL = aa_strct_size(ac);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_strct_2_prob_vec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_strct_2_prob_vec)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Wurst::strct_2_prob_vec(structure, cmodel, norm)");
    {
	Coord *	structure;
	Aa_strct_clssfcn *	cmodel;
	int	norm = (int)SvIV(ST(2));
	Prob_vec *	RETVAL;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    structure = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "structure is not of type CoordPtr");

	if (sv_derived_from(ST(1), "Aa_strct_clssfcnPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    cmodel = INT2PTR(Aa_strct_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "cmodel is not of type Aa_strct_clssfcnPtr");

	RETVAL = strct_2_prob_vec(structure, cmodel, norm);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Prob_vecPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_strct_2_duplicated_prob_vec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_strct_2_duplicated_prob_vec)
{
    dXSARGS;
    if (items != 6)
	Perl_croak(aTHX_ "Usage: Wurst::strct_2_duplicated_prob_vec(structure, seq, sp, size, cmodel, n_duplications)");
    {
	Coord *	structure;
	Seq *	seq;
	Seqprof *	sp;
	size_t	size = (size_t)SvUV(ST(3));
	Aa_strct_clssfcn *	cmodel;
	size_t	n_duplications = (size_t)SvUV(ST(5));
	Prob_vec *	RETVAL;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    structure = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "structure is not of type CoordPtr");

	if (sv_derived_from(ST(1), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    seq = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "seq is not of type SeqPtr");

	if (sv_derived_from(ST(2), "SeqprofPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    sp = INT2PTR(Seqprof *,tmp);
	}
	else
	    Perl_croak(aTHX_ "sp is not of type SeqprofPtr");

	if (sv_derived_from(ST(4), "Aa_strct_clssfcnPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(4)));
	    cmodel = INT2PTR(Aa_strct_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "cmodel is not of type Aa_strct_clssfcnPtr");

	RETVAL = strct_2_duplicated_prob_vec(structure, seq, sp, size, cmodel, n_duplications);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Prob_vecPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_aa_strct_2_prob_vec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_aa_strct_2_prob_vec)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Wurst::aa_strct_2_prob_vec(structure, cmodel, norm)");
    {
	Coord *	structure;
	Aa_strct_clssfcn *	cmodel;
	int	norm = (int)SvIV(ST(2));
	Prob_vec *	RETVAL;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    structure = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "structure is not of type CoordPtr");

	if (sv_derived_from(ST(1), "Aa_strct_clssfcnPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    cmodel = INT2PTR(Aa_strct_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "cmodel is not of type Aa_strct_clssfcnPtr");

	RETVAL = aa_strct_2_prob_vec(structure, cmodel, norm);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Prob_vecPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_prof_aa_strct_2_prob_vec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_prof_aa_strct_2_prob_vec)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: Wurst::prof_aa_strct_2_prob_vec(structure, sp, cmodel, norm)");
    {
	Coord *	structure;
	Seqprof *	sp;
	Aa_strct_clssfcn *	cmodel;
	int	norm = (int)SvIV(ST(3));
	Prob_vec *	RETVAL;

	if (sv_derived_from(ST(0), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    structure = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "structure is not of type CoordPtr");

	if (sv_derived_from(ST(1), "SeqprofPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    sp = INT2PTR(Seqprof *,tmp);
	}
	else
	    Perl_croak(aTHX_ "sp is not of type SeqprofPtr");

	if (sv_derived_from(ST(2), "Aa_strct_clssfcnPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    cmodel = INT2PTR(Aa_strct_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "cmodel is not of type Aa_strct_clssfcnPtr");

	RETVAL = prof_aa_strct_2_prob_vec(structure, sp, cmodel, norm);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Prob_vecPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_aa_2_prob_vec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_aa_2_prob_vec)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Wurst::aa_2_prob_vec(seq, cmodel, norm)");
    {
	Seq *	seq;
	Aa_strct_clssfcn *	cmodel;
	int	norm = (int)SvIV(ST(2));
	Prob_vec *	RETVAL;

	if (sv_derived_from(ST(0), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    seq = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "seq is not of type SeqPtr");

	if (sv_derived_from(ST(1), "Aa_strct_clssfcnPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    cmodel = INT2PTR(Aa_strct_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "cmodel is not of type Aa_strct_clssfcnPtr");

	RETVAL = aa_2_prob_vec(seq, cmodel, norm);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Prob_vecPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_prof_aa_2_prob_vec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_prof_aa_2_prob_vec)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Wurst::prof_aa_2_prob_vec(sp, cmodel, norm)");
    {
	Seqprof *	sp;
	Aa_strct_clssfcn *	cmodel;
	int	norm = (int)SvIV(ST(2));
	Prob_vec *	RETVAL;

	if (sv_derived_from(ST(0), "SeqprofPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sp = INT2PTR(Seqprof *,tmp);
	}
	else
	    Perl_croak(aTHX_ "sp is not of type SeqprofPtr");

	if (sv_derived_from(ST(1), "Aa_strct_clssfcnPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    cmodel = INT2PTR(Aa_strct_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "cmodel is not of type Aa_strct_clssfcnPtr");

	RETVAL = prof_aa_2_prob_vec(sp, cmodel, norm);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Prob_vecPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_aa_strct_clssfcn_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_aa_strct_clssfcn_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::aa_strct_clssfcn_DESTROY(aa)");
    {
	Aa_strct_clssfcn *	aa;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    aa = INT2PTR(Aa_strct_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "aa is not a reference");
#line 1134 "Wurst.xs"
        aa_strct_clssfcn_destroy (aa);
#line 3680 "Wurst.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_Wurst_ac_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_ac_read)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::ac_read(fname)");
    {
	const char *	fname = (const char *)SvPV_nolen(ST(0));
	Aa_clssfcn *	RETVAL;

	RETVAL = ac_read(fname);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Aa_clssfcnPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_ac_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_ac_size)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::ac_size(ac)");
    {
	Aa_clssfcn *	ac;
	size_t	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Aa_clssfcnPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ac = INT2PTR(Aa_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "ac is not of type Aa_clssfcnPtr");

	RETVAL = ac_size(ac);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_ac_nclass); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_ac_nclass)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::ac_nclass(ac)");
    {
	Aa_clssfcn *	ac;
	size_t	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Aa_clssfcnPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ac = INT2PTR(Aa_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "ac is not of type Aa_clssfcnPtr");

	RETVAL = ac_nclass(ac);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_ac_dump); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_ac_dump)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::ac_dump(ac)");
    {
	Aa_clssfcn *	ac;

	if (sv_derived_from(ST(0), "Aa_clssfcnPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ac = INT2PTR(Aa_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "ac is not of type Aa_clssfcnPtr");

	ac_dump(ac);
    }
    XSRETURN_EMPTY;
}

XS(XS_Wurst_computeMembershipAAProf); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_computeMembershipAAProf)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Wurst::computeMembershipAAProf(mship, sp, ac)");
    {
	float **	mship;
	Seqprof *	sp;
	Aa_clssfcn *	ac;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "floatPtrPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mship = INT2PTR(float **,tmp);
	}
	else
	    Perl_croak(aTHX_ "mship is not of type floatPtrPtr");

	if (sv_derived_from(ST(1), "SeqprofPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    sp = INT2PTR(Seqprof *,tmp);
	}
	else
	    Perl_croak(aTHX_ "sp is not of type SeqprofPtr");

	if (sv_derived_from(ST(2), "Aa_clssfcnPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    ac = INT2PTR(Aa_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "ac is not of type Aa_clssfcnPtr");
#line 1163 "Wurst.xs"
        RETVAL = computeMembershipAAProf (mship, sp, ac);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 3810 "Wurst.c"
    }
    XSRETURN(1);
}

XS(XS_Wurst_computeMembershipAA); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_computeMembershipAA)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Wurst::computeMembershipAA(mship, seq, ac)");
    {
	float **	mship;
	Seq *	seq;
	Aa_clssfcn *	ac;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "floatPtrPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mship = INT2PTR(float **,tmp);
	}
	else
	    Perl_croak(aTHX_ "mship is not of type floatPtrPtr");

	if (sv_derived_from(ST(1), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    seq = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "seq is not of type SeqPtr");

	if (sv_derived_from(ST(2), "Aa_clssfcnPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    ac = INT2PTR(Aa_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "ac is not of type Aa_clssfcnPtr");
#line 1175 "Wurst.xs"
        RETVAL = computeMembershipAA (mship, seq, ac);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 3854 "Wurst.c"
    }
    XSRETURN(1);
}

XS(XS_Wurst_seq_2_prob_vec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_seq_2_prob_vec)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Wurst::seq_2_prob_vec(seq, ac)");
    {
	Seq *	seq;
	Aa_clssfcn *	ac;
	Prob_vec *	RETVAL;

	if (sv_derived_from(ST(0), "SeqPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    seq = INT2PTR(Seq *,tmp);
	}
	else
	    Perl_croak(aTHX_ "seq is not of type SeqPtr");

	if (sv_derived_from(ST(1), "Aa_clssfcnPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    ac = INT2PTR(Aa_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "ac is not of type Aa_clssfcnPtr");

	RETVAL = seq_2_prob_vec(seq, ac);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Prob_vecPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Aa_clssfcnPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Aa_clssfcnPtr_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Aa_clssfcnPtr::DESTROY(aa)");
    {
	Aa_clssfcn *	aa;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    aa = INT2PTR(Aa_clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "aa is not a reference");
#line 1191 "Wurst.xs"
        aa_clssfcn_destroy (aa);
#line 3908 "Wurst.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_Wurst_dpt_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_dpt_read)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::dpt_read(fname)");
    {
	const char *	fname = (const char *)SvPV_nolen(ST(0));
	Dpt_list *	RETVAL;

	RETVAL = dpt_read(fname);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Dpt_listPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_dpt_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_dpt_string)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::dpt_string(d_p)");
    {
	Dpt_list *	d_p;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Dpt_listPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    d_p = INT2PTR(Dpt_list *,tmp);
	}
	else
	    Perl_croak(aTHX_ "d_p is not of type Dpt_listPtr");

	RETVAL = dpt_string(d_p);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_Wurst_dpt_get_n); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_dpt_get_n)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Wurst::dpt_get_n(d_p)");
    {
	Dpt_list *	d_p;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Dpt_listPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    d_p = INT2PTR(Dpt_list *,tmp);
	}
	else
	    Perl_croak(aTHX_ "d_p is not of type Dpt_listPtr");

	RETVAL = dpt_get_n(d_p);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_dpt_get_val); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_dpt_get_val)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Wurst::dpt_get_val(d_p, n)");
    {
	Dpt_list *	d_p;
	size_t	n = (size_t)SvUV(ST(1));
	float	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Dpt_listPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    d_p = INT2PTR(Dpt_list *,tmp);
	}
	else
	    Perl_croak(aTHX_ "d_p is not of type Dpt_listPtr");
#line 1216 "Wurst.xs"
        {
            int error;
            RETVAL = dpt_get_val (d_p, n, &error);
            if (error == EXIT_FAILURE)
                XSRETURN_UNDEF;
        }
#line 4003 "Wurst.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_dpt_set_val); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_dpt_set_val)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Wurst::dpt_set_val(d_p, n, val)");
    {
	Dpt_list *	d_p;
	size_t	n = (size_t)SvUV(ST(1));
	float	val = (float)SvNV(ST(2));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Dpt_listPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    d_p = INT2PTR(Dpt_list *,tmp);
	}
	else
	    Perl_croak(aTHX_ "d_p is not of type Dpt_listPtr");
#line 1231 "Wurst.xs"
        RETVAL = dpt_set_val (d_p, n, val);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
        else
            RETVAL = 1;
#line 4034 "Wurst.c"
    }
    XSRETURN(1);
}

XS(XS_Dpt_listPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Dpt_listPtr_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Dpt_listPtr::DESTROY(d_p)");
    {
	Dpt_list *	d_p;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    d_p = INT2PTR(Dpt_list *,tmp);
	}
	else
	    Perl_croak(aTHX_ "d_p is not a reference");
#line 1242 "Wurst.xs"
        dpt_list_destroy (d_p);
#line 4056 "Wurst.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_Wurst_find_alt_path_score_simple); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_find_alt_path_score_simple)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Wurst::find_alt_path_score_simple(score_mat, pair_set)");
    {
	float	RETVAL;
	dXSTARG;
	Score_mat *	score_mat;
	Pair_set *	pair_set;

	if (sv_derived_from(ST(0), "Score_matPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    score_mat = INT2PTR(Score_mat *,tmp);
	}
	else
	    Perl_croak(aTHX_ "score_mat is not of type Score_matPtr");

	if (sv_derived_from(ST(1), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    pair_set = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "pair_set is not of type Pair_setPtr");

	RETVAL = find_alt_path_score_simple(score_mat, pair_set);
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_get_clssfcn); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_get_clssfcn)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Wurst::get_clssfcn(influence_report_filename, abs_error)");
    {
	const char *	influence_report_filename = (const char *)SvPV_nolen(ST(0));
	float	abs_error = (float)SvNV(ST(1));
	Clssfcn *	RETVAL;

	RETVAL = get_clssfcn(influence_report_filename, abs_error);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "ClssfcnPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_computeMembership); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_computeMembership)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Wurst::computeMembership(mship, test_vec, cmodel)");
    {
	float *	mship;
	float *	test_vec;
	Clssfcn *	cmodel;
	float *	RETVAL;

	if (sv_derived_from(ST(0), "floatPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mship = INT2PTR(float *,tmp);
	}
	else
	    Perl_croak(aTHX_ "mship is not of type floatPtr");

	if (sv_derived_from(ST(1), "floatPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    test_vec = INT2PTR(float *,tmp);
	}
	else
	    Perl_croak(aTHX_ "test_vec is not of type floatPtr");

	if (sv_derived_from(ST(2), "ClssfcnPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    cmodel = INT2PTR(Clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "cmodel is not of type ClssfcnPtr");

	RETVAL = computeMembership(mship, test_vec, cmodel);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "floatPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_ClssfcnPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_ClssfcnPtr_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: ClssfcnPtr::DESTROY(c)");
    {
	Clssfcn *	c;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    c = INT2PTR(Clssfcn *,tmp);
	}
	else
	    Perl_croak(aTHX_ "c is not a reference");
#line 1280 "Wurst.xs"
        clssfcn_destroy (c);
#line 4168 "Wurst.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_Wurst_merge_alignments); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_merge_alignments)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Wurst::merge_alignments(align1, align2, alignment)");
    {
	Pair_set *	align1;
	Pair_set *	align2;
	Pair_set *	alignment;
	Pair_set *	RETVAL;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    align1 = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "align1 is not of type Pair_setPtr");

	if (sv_derived_from(ST(1), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    align2 = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "align2 is not of type Pair_setPtr");

	if (sv_derived_from(ST(2), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    alignment = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "alignment is not of type Pair_setPtr");

	RETVAL = merge_alignments(align1, align2, alignment);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Pair_setPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_pvec_avg); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_pvec_avg)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: Wurst::pvec_avg(p_vec1, p_vec2, p_set, cur_step)");
    {
	Prob_vec *	p_vec1;
	Prob_vec *	p_vec2;
	Pair_set *	p_set;
	int	cur_step = (int)SvIV(ST(3));
	Prob_vec *	RETVAL;

	if (sv_derived_from(ST(0), "Prob_vecPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    p_vec1 = INT2PTR(Prob_vec *,tmp);
	}
	else
	    Perl_croak(aTHX_ "p_vec1 is not of type Prob_vecPtr");

	if (sv_derived_from(ST(1), "Prob_vecPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    p_vec2 = INT2PTR(Prob_vec *,tmp);
	}
	else
	    Perl_croak(aTHX_ "p_vec2 is not of type Prob_vecPtr");

	if (sv_derived_from(ST(2), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    p_set = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "p_set is not of type Pair_setPtr");

	RETVAL = pvec_avg(p_vec1, p_vec2, p_set, cur_step);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Prob_vecPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_remove_seq); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_remove_seq)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Wurst::remove_seq(pairset, index)");
    {
	Pair_set *	pairset;
	int	index = (int)SvIV(ST(1));
	Pair_set *	RETVAL;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pairset = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "pairset is not of type Pair_setPtr");

	RETVAL = remove_seq(pairset, index);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Pair_setPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_split_multal); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_split_multal)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Wurst::split_multal(pairset, a, b)");
    {
	Pair_set *	pairset;
	int	a = (int)SvIV(ST(1));
	int	b = (int)SvIV(ST(2));
	Pair_set *	RETVAL;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pairset = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "pairset is not of type Pair_setPtr");

	RETVAL = split_multal(pairset, a, b);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Pair_setPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Wurst_coord_rmsd); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_coord_rmsd)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: Wurst::coord_rmsd(pair_set, coord1, coord2, sub_flag)");
    {
	int	RETVAL;
	dXSTARG;
	Pair_set *	pair_set;
	Coord *	coord1;
	Coord *	coord2;
	int	sub_flag = (int)SvIV(ST(3));
	float	rmsd;
	Coord *	c1_new;
	Coord *	c2_new;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pair_set = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "pair_set is not of type Pair_setPtr");

	if (sv_derived_from(ST(1), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    coord1 = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "coord1 is not of type CoordPtr");

	if (sv_derived_from(ST(2), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    coord2 = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "coord2 is not of type CoordPtr");
#line 1321 "Wurst.xs"
        RETVAL = coord_rmsd(pair_set, coord1, coord2, sub_flag, &rmsd, &c1_new, &c2_new);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
#line 4346 "Wurst.c"
	XSprePUSH;	EXTEND(SP,3);
	PUSHs(sv_newmortal());
	sv_setnv(ST(0), (double)rmsd);
	PUSHs(sv_newmortal());
	sv_setref_pv(ST(1), "CoordPtr", (void*)c1_new);
	PUSHs(sv_newmortal());
	sv_setref_pv(ST(2), "CoordPtr", (void*)c2_new);
    }
    XSRETURN(3);
}

XS(XS_Wurst_get_rmsd); /* prototype to pass -Wmissing-prototypes */
XS(XS_Wurst_get_rmsd)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Wurst::get_rmsd(pairset, r1, r2)");
    {
	int	RETVAL;
	dXSTARG;
	Pair_set *	pairset;
	Coord *	r1;
	Coord *	r2;
	float	rmsd;
	int	count;

	if (sv_derived_from(ST(0), "Pair_setPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pairset = INT2PTR(Pair_set *,tmp);
	}
	else
	    Perl_croak(aTHX_ "pairset is not of type Pair_setPtr");

	if (sv_derived_from(ST(1), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    r1 = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "r1 is not of type CoordPtr");

	if (sv_derived_from(ST(2), "CoordPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    r2 = INT2PTR(Coord *,tmp);
	}
	else
	    Perl_croak(aTHX_ "r2 is not of type CoordPtr");
#line 1330 "Wurst.xs"
		RETVAL = get_rmsd(pairset, r1, r2, &rmsd, &count);
        if (RETVAL == EXIT_FAILURE)
            XSRETURN_UNDEF;
#line 4397 "Wurst.c"
	XSprePUSH;	EXTEND(SP,2);
	PUSHs(sv_newmortal());
	sv_setnv(ST(0), (double)rmsd);
	PUSHs(sv_newmortal());
	sv_setiv(ST(1), (IV)count);
    }
    XSRETURN(2);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Wurst); /* prototype to pass -Wmissing-prototypes */
XS(boot_Wurst)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        newXSproto("Wurst::constant", XS_Wurst_constant, file, "$$");
        newXSproto("Wurst::file_pre_read", XS_Wurst_file_pre_read, file, "$");
        newXSproto("Wurst::sec_s_data_read", XS_Wurst_sec_s_data_read, file, "$");
        newXSproto("Wurst::sec_s_data_string", XS_Wurst_sec_s_data_string, file, "$");
        newXSproto("Sec_s_dataPtr::DESTROY", XS_Sec_s_dataPtr_DESTROY, file, "$");
        newXSproto("Wurst::seq_read", XS_Wurst_seq_read, file, "$");
        newXSproto("Wurst::seq_from_string", XS_Wurst_seq_from_string, file, "$");
        newXSproto("Wurst::seq_get_1", XS_Wurst_seq_get_1, file, "$$");
        newXSproto("Wurst::seq_num", XS_Wurst_seq_num, file, "$");
        newXSproto("Wurst::seq_size", XS_Wurst_seq_size, file, "$");
        newXSproto("Wurst::seq_print", XS_Wurst_seq_print, file, "$");
        newXSproto("Wurst::seq_read_many", XS_Wurst_seq_read_many, file, "$;$");
        newXSproto("Wurst::seq_print_many", XS_Wurst_seq_print_many, file, "$");
        newXSproto("Wurst::seq_duplicate", XS_Wurst_seq_duplicate, file, "$$");
        newXSproto("SeqPtr::DESTROY", XS_SeqPtr_DESTROY, file, "$");
        newXSproto("Seq_arrayPtrPtr::DESTROY", XS_Seq_arrayPtrPtr_DESTROY, file, "$");
        newXSproto("Wurst::sub_mat_read", XS_Wurst_sub_mat_read, file, "$");
        newXSproto("Wurst::sub_mat_string", XS_Wurst_sub_mat_string, file, "$");
        newXSproto("Wurst::sub_mat_shift", XS_Wurst_sub_mat_shift, file, "$$");
        newXSproto("Wurst::sub_mat_scale", XS_Wurst_sub_mat_scale, file, "$$$");
        newXSproto("Wurst::sub_mat_get_by_i", XS_Wurst_sub_mat_get_by_i, file, "$$$");
        newXSproto("Wurst::sub_mat_get_by_c", XS_Wurst_sub_mat_get_by_c, file, "$$$");
        newXSproto("Wurst::sub_mat_set_by_i", XS_Wurst_sub_mat_set_by_i, file, "$$$$");
        newXSproto("Wurst::sub_mat_set_by_c", XS_Wurst_sub_mat_set_by_c, file, "$$$$");
        newXSproto("Sub_matPtr::DESTROY", XS_Sub_matPtr_DESTROY, file, "$");
        newXSproto("Wurst::coord_2_bin", XS_Wurst_coord_2_bin, file, "$$");
        newXSproto("Wurst::coord_name", XS_Wurst_coord_name, file, "$");
        newXSproto("Wurst::coord_size", XS_Wurst_coord_size, file, "$");
        newXSproto("Wurst::coord_read", XS_Wurst_coord_read, file, "$");
        newXSproto("Wurst::coord_get_seq", XS_Wurst_coord_get_seq, file, "$");
        newXSproto("Wurst::coord_has_sec_s", XS_Wurst_coord_has_sec_s, file, "$");
        newXSproto("Wurst::coord_get_sec_s", XS_Wurst_coord_get_sec_s, file, "$");
        newXSproto("Wurst::coord_2_pdb", XS_Wurst_coord_2_pdb, file, "$$;$");
        newXSproto("Wurst::coord_2_spdb", XS_Wurst_coord_2_spdb, file, "$$$;$");
        newXSproto("Wurst::coord_c_n_dist", XS_Wurst_coord_c_n_dist, file, "$$$$");
        newXSproto("Wurst::coord_calc_psi", XS_Wurst_coord_calc_psi, file, "$");
        newXSproto("Wurst::coord_calc_phi", XS_Wurst_coord_calc_phi, file, "$");
        newXSproto("Wurst::coord_psi", XS_Wurst_coord_psi, file, "$$$");
        newXSproto("Wurst::coord_phi", XS_Wurst_coord_phi, file, "$$$");
        newXSproto("Wurst::coord_geo_gap", XS_Wurst_coord_geo_gap, file, "$$$");
        newXSproto("Wurst::dme_thresh", XS_Wurst_dme_thresh, file, "$$$$");
        newXSproto("Wurst::pdb_read", XS_Wurst_pdb_read, file, "$$$");
        newXSproto("CoordPtr::DESTROY", XS_CoordPtr_DESTROY, file, "$");
        newXSproto("Wurst::make_model", XS_Wurst_make_model, file, "$$$");
        newXSproto("Wurst::mc_run", XS_Wurst_mc_run, file, "$$$");
        newXSproto("Wurst::model_pdb_num", XS_Wurst_model_pdb_num, file, "$$");
        newXSproto("Wurst::model_res_num", XS_Wurst_model_res_num, file, "$$");
        newXSproto("Wurst::coord_2_pnlty", XS_Wurst_coord_2_pnlty, file, "$$");
        newXSproto("Wurst::score_mat_new", XS_Wurst_score_mat_new, file, "$$");
        newXSproto("Wurst::score_mat_read", XS_Wurst_score_mat_read, file, "$");
        newXSproto("Wurst::score_mat_add", XS_Wurst_score_mat_add, file, "$$$;$");
        newXSproto("Wurst::score_mat_info", XS_Wurst_score_mat_info, file, "$");
        newXSproto("Wurst::score_mat_scale", XS_Wurst_score_mat_scale, file, "$$");
        newXSproto("Wurst::score_mat_shift", XS_Wurst_score_mat_shift, file, "$$");
        newXSproto("Wurst::score_mat_write", XS_Wurst_score_mat_write, file, "$$");
        newXSproto("Wurst::score_mat_diag_wipe", XS_Wurst_score_mat_diag_wipe, file, "$$");
        newXSproto("Wurst::score_mat_double_matrix", XS_Wurst_score_mat_double_matrix, file, "$");
        newXSproto("Wurst::score_mat_write_gnuplot", XS_Wurst_score_mat_write_gnuplot, file, "$$$$");
        newXSproto("Wurst::score_dpt", XS_Wurst_score_dpt, file, "$$$$");
        newXSproto("Wurst::score_prof_prof", XS_Wurst_score_prof_prof, file, "$$$$");
        newXSproto("Wurst::score_smat", XS_Wurst_score_smat, file, "$$$$");
        newXSproto("Wurst::score_sprof", XS_Wurst_score_sprof, file, "$$$$");
        newXSproto("Wurst::score_fx", XS_Wurst_score_fx, file, "$$$$");
        newXSproto("Wurst::score_fx_prof", XS_Wurst_score_fx_prof, file, "$$$$");
        newXSproto("Wurst::score_sec", XS_Wurst_score_sec, file, "$$$");
        newXSproto("Wurst::param_rs_read", XS_Wurst_param_rs_read, file, "$");
        newXSproto("Wurst::score_rs", XS_Wurst_score_rs, file, "$$");
        newXSproto("Wurst::param_fx_read", XS_Wurst_param_fx_read, file, "$");
        newXSproto("RSParamPtr::DESTROY", XS_RSParamPtr_DESTROY, file, "$");
        newXSproto("FXParamPtr::DESTROY", XS_FXParamPtr_DESTROY, file, "$");
        newXSproto("Wurst::score_mat_string", XS_Wurst_score_mat_string, file, "$$$");
        newXSproto("Wurst::score_pvec_quadrifiedsmat", XS_Wurst_score_pvec_quadrifiedsmat, file, "$$$");
        newXSproto("Wurst::score_mat_sum_full", XS_Wurst_score_mat_sum_full, file, "$$$$$$$$$;$");
        newXSproto("floatPtr::DESTROY", XS_floatPtr_DESTROY, file, "$");
        newXSproto("Score_matPtr::DESTROY", XS_Score_matPtr_DESTROY, file, "$");
        newXSproto("Wurst::pair_set_chimera", XS_Wurst_pair_set_chimera, file, "$$$");
        newXSproto("Wurst::pair_set_coverage", XS_Wurst_pair_set_coverage, file, "$$$");
        newXSproto("Wurst::pair_set_gap", XS_Wurst_pair_set_gap, file, "$$$");
        newXSproto("Wurst::pair_set_string", XS_Wurst_pair_set_string, file, "$$$");
        newXSproto("Wurst::multal_string", XS_Wurst_multal_string, file, "$");
        newXSproto("Wurst::pair_set_pretty_string", XS_Wurst_pair_set_pretty_string, file, "$$$;$$");
        newXSproto("Wurst::pair_set_get_alignment_indices", XS_Wurst_pair_set_get_alignment_indices, file, "$$");
        newXSproto("Wurst::pair_set_circularpermutated", XS_Wurst_pair_set_circularpermutated, file, "$$$");
        newXSproto("Wurst::get_seq_id_simple", XS_Wurst_get_seq_id_simple, file, "$$$");
        newXSproto("Wurst::pair_set_score", XS_Wurst_pair_set_score, file, "$");
        newXSproto("Wurst::pair_set_extend", XS_Wurst_pair_set_extend, file, "$$$$");
        newXSproto("Pair_setPtr::DESTROY", XS_Pair_setPtr_DESTROY, file, "$");
        newXSproto("Wurst::func_int", XS_Wurst_func_int, file, "");
        newXSproto("Wurst::func_float", XS_Wurst_func_float, file, "");
        newXSproto("Wurst::func_char", XS_Wurst_func_char, file, "");
        newXSproto("Wurst::funcs1_char", XS_Wurst_funcs1_char, file, "$");
        newXSproto("Wurst::funcs2_char", XS_Wurst_funcs2_char, file, "");
        newXSproto("Wurst::free_scratch", XS_Wurst_free_scratch, file, "");
        newXSproto("Wurst::get_nbor", XS_Wurst_get_nbor, file, "$");
        newXSproto("Wurst::get_solv_data", XS_Wurst_get_solv_data, file, "$");
        newXSproto("Wurst::get_torsion_data", XS_Wurst_get_torsion_data, file, "$");
        newXSproto("Wurst::blst_chk_read", XS_Wurst_blst_chk_read, file, "$");
        newXSproto("Wurst::seqprof_str", XS_Wurst_seqprof_str, file, "$");
        newXSproto("Wurst::seqprof_get_seq", XS_Wurst_seqprof_get_seq, file, "$");
        newXSproto("SeqprofPtr::DESTROY", XS_SeqprofPtr_DESTROY, file, "$");
        newXSproto("Wurst::scor_set_fromvec", XS_Wurst_scor_set_fromvec, file, "$");
        newXSproto("Wurst::scor_set_to_vec", XS_Wurst_scor_set_to_vec, file, "$");
        newXSproto("Wurst::scor_set_simpl", XS_Wurst_scor_set_simpl, file, "$$");
        newXSproto("Wurst::scor_set_scale", XS_Wurst_scor_set_scale, file, "$$");
        newXSproto("Scor_setPtr::DESTROY", XS_Scor_setPtr_DESTROY, file, "$");
        newXSproto("Wurst::prob_vec_info", XS_Wurst_prob_vec_info, file, "$");
        newXSproto("Wurst::score_pvec", XS_Wurst_score_pvec, file, "$$$");
        newXSproto("Wurst::prob_vec_size", XS_Wurst_prob_vec_size, file, "$");
        newXSproto("Wurst::prob_vec_length", XS_Wurst_prob_vec_length, file, "$");
        newXSproto("Wurst::prob_vec_copy", XS_Wurst_prob_vec_copy, file, "$");
        newXSproto("Wurst::prob_vec_write", XS_Wurst_prob_vec_write, file, "$$");
        newXSproto("Wurst::prob_vec_read", XS_Wurst_prob_vec_read, file, "$");
        newXSproto("Wurst::prob_vec_duplicate", XS_Wurst_prob_vec_duplicate, file, "$$");
        newXSproto("Prob_vecPtr::DESTROY", XS_Prob_vecPtr_DESTROY, file, "$");
        newXSproto("Wurst::aa_strct_clssfcn_read", XS_Wurst_aa_strct_clssfcn_read, file, "$$");
        newXSproto("Wurst::aa_strct_dump", XS_Wurst_aa_strct_dump, file, "$");
        newXSproto("Wurst::aa_strct_nclass", XS_Wurst_aa_strct_nclass, file, "$");
        newXSproto("Wurst::aa_strct_size", XS_Wurst_aa_strct_size, file, "$");
        newXSproto("Wurst::strct_2_prob_vec", XS_Wurst_strct_2_prob_vec, file, "$$$");
        newXSproto("Wurst::strct_2_duplicated_prob_vec", XS_Wurst_strct_2_duplicated_prob_vec, file, "$$$$$$");
        newXSproto("Wurst::aa_strct_2_prob_vec", XS_Wurst_aa_strct_2_prob_vec, file, "$$$");
        newXSproto("Wurst::prof_aa_strct_2_prob_vec", XS_Wurst_prof_aa_strct_2_prob_vec, file, "$$$$");
        newXSproto("Wurst::aa_2_prob_vec", XS_Wurst_aa_2_prob_vec, file, "$$$");
        newXSproto("Wurst::prof_aa_2_prob_vec", XS_Wurst_prof_aa_2_prob_vec, file, "$$$");
        newXSproto("Wurst::aa_strct_clssfcn_DESTROY", XS_Wurst_aa_strct_clssfcn_DESTROY, file, "$");
        newXSproto("Wurst::ac_read", XS_Wurst_ac_read, file, "$");
        newXSproto("Wurst::ac_size", XS_Wurst_ac_size, file, "$");
        newXSproto("Wurst::ac_nclass", XS_Wurst_ac_nclass, file, "$");
        newXSproto("Wurst::ac_dump", XS_Wurst_ac_dump, file, "$");
        newXSproto("Wurst::computeMembershipAAProf", XS_Wurst_computeMembershipAAProf, file, "$$$");
        newXSproto("Wurst::computeMembershipAA", XS_Wurst_computeMembershipAA, file, "$$$");
        newXSproto("Wurst::seq_2_prob_vec", XS_Wurst_seq_2_prob_vec, file, "$$");
        newXSproto("Aa_clssfcnPtr::DESTROY", XS_Aa_clssfcnPtr_DESTROY, file, "$");
        newXSproto("Wurst::dpt_read", XS_Wurst_dpt_read, file, "$");
        newXSproto("Wurst::dpt_string", XS_Wurst_dpt_string, file, "$");
        newXSproto("Wurst::dpt_get_n", XS_Wurst_dpt_get_n, file, "$");
        newXSproto("Wurst::dpt_get_val", XS_Wurst_dpt_get_val, file, "$$");
        newXSproto("Wurst::dpt_set_val", XS_Wurst_dpt_set_val, file, "$$$");
        newXSproto("Dpt_listPtr::DESTROY", XS_Dpt_listPtr_DESTROY, file, "$");
        newXSproto("Wurst::find_alt_path_score_simple", XS_Wurst_find_alt_path_score_simple, file, "$$");
        newXSproto("Wurst::get_clssfcn", XS_Wurst_get_clssfcn, file, "$$");
        newXSproto("Wurst::computeMembership", XS_Wurst_computeMembership, file, "$$$");
        newXSproto("ClssfcnPtr::DESTROY", XS_ClssfcnPtr_DESTROY, file, "$");
        newXSproto("Wurst::merge_alignments", XS_Wurst_merge_alignments, file, "$$$");
        newXSproto("Wurst::pvec_avg", XS_Wurst_pvec_avg, file, "$$$$");
        newXSproto("Wurst::remove_seq", XS_Wurst_remove_seq, file, "$$");
        newXSproto("Wurst::split_multal", XS_Wurst_split_multal, file, "$$$");
        newXSproto("Wurst::coord_rmsd", XS_Wurst_coord_rmsd, file, "$$$$");
        newXSproto("Wurst::get_rmsd", XS_Wurst_get_rmsd, file, "$$$");
    XSRETURN_YES;
}

